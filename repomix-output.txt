This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-12-11T15:59:12.679Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
app/
  actions.ts
  globals.css
  layout.tsx
  page.tsx
components/
  chat/
    BookReviewCard.tsx
    ChatInput.tsx
    ChatInterface.tsx
    ChatMessage.tsx
  ui/
    avatar.tsx
    badge.tsx
    button.tsx
    card.tsx
    input.tsx
    scroll-area.tsx
    textarea.tsx
  ChatContainer.tsx
lib/
  services/
    chat.ts
    pinecone.ts
  validators/
    book-data.ts
  utils.ts
public/
  file.svg
  globe.svg
  next.svg
  vercel.svg
  window.svg
scripts/
  inspect-db.ts
types/
  chat.ts
.eslintrc.json
.gitignore
components.json
next.config.js
package.json
postcss.config.js
postcss.config.mjs
README.md
tailwind.config.ts
tsconfig.json

================================================================
Repository Files
================================================================

================
File: app/actions.ts
================
'use server';

import { createStreamableValue } from 'ai/rsc';
import { type Message } from 'ai';
import { chatService } from '@/lib/services/chat';

export type { Message };

// Increased timeout to 60 seconds
const STREAM_TIMEOUT = 60000;

// Rate limiting constants
const RATE_LIMIT = {
  MAX_REQUESTS: 50,
  WINDOW_MS: 60000, // 1 minute
};

// In-memory rate limiting (replace with Redis in production)
const rateLimitStore = new Map<string, number[]>();

function isRateLimited(userId: string): boolean {
  const now = Date.now();
  const userRequests = rateLimitStore.get(userId) || [];

  // Clean old requests
  const recentRequests = userRequests.filter(
    timestamp => now - timestamp < RATE_LIMIT.WINDOW_MS
  );

  if (recentRequests.length >= RATE_LIMIT.MAX_REQUESTS) {
    return true;
  }

  recentRequests.push(now);
  rateLimitStore.set(userId, recentRequests);
  return false;
}

export async function continueConversation(
  history: Message[],
  userId: string = 'anonymous'
) {
  const stream = createStreamableValue();

  // Check rate limit
  if (isRateLimited(userId)) {
    stream.update("I apologize, but you've reached the rate limit. Please try again in a minute.");
    stream.done();
    return {
      messages: history,
      newMessage: stream.value,
    };
  }

  // Create timeout promise
  const timeoutPromise = new Promise((_, reject) => {
    setTimeout(() => {
      reject(new Error('Stream timeout'));
    }, STREAM_TIMEOUT);
  });

  (async () => {
    try {
      const latestMessage = history[history.length - 1].content;
      console.log('Processing message:', latestMessage);

      const textStream = await chatService.processMessage(history);
      let fullResponse = '';
      let lastUpdate = Date.now();

      await Promise.race([
        (async () => {
          for await (const chunk of textStream) {
            fullResponse += chunk;

            // Rate limit updates to every 100ms
            const now = Date.now();
            if (now - lastUpdate >= 100) {
              stream.update(chunk);
              lastUpdate = now;
            }
          }
        })(),
        timeoutPromise
      ]);

      if (fullResponse) {
        stream.update(fullResponse);
        console.log('Completed response:', fullResponse.slice(0, 200) + '...');
      }

      stream.done();

    } catch (error) {
      console.error('Error in chat stream:', error);

      let errorMessage: string;

      if (error instanceof Error) {
        if (error.message === 'Stream timeout') {
          errorMessage = "I apologize, but the response took too long. Please try a shorter query or try again.";
        } else if (error.message.includes('database')) {
          errorMessage = "I apologize, but I encountered an error accessing the review database. This has been logged and will be investigated.";
        } else {
          errorMessage = "I apologize, but I encountered an error processing your request. Please try again in a moment.";
        }
      } else {
        errorMessage = "An unexpected error occurred. Please try again.";
      }

      stream.update(errorMessage);
      stream.done();
    }
  })();

  return {
    messages: history,
    newMessage: stream.value,
  };
}

================
File: app/globals.css
================
@tailwind base;
@tailwind components;
@tailwind utilities;
 
@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 240 10% 3.9%;
    --card: 0 0% 100%;
    --card-foreground: 240 10% 3.9%;
    --popover: 0 0% 100%;
    --popover-foreground: 240 10% 3.9%;
    --primary: 236 35% 63%;
    --primary-foreground: 0 0% 98%;
    --secondary: 240 4.8% 95.9%;
    --secondary-foreground: 240 5.9% 10%;
    --muted: 240 4.8% 95.9%;
    --muted-foreground: 240 3.8% 46.1%;
    --accent: 240 4.8% 95.9%;
    --accent-foreground: 240 5.9% 10%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 0 0% 98%;
    --border: 240 5.9% 90%;
    --input: 240 5.9% 90%;
    --ring: 236 35% 63%;
    --radius: 0.5rem;
  }
 
  .dark {
    --background: 240 10% 3.9%;
    --foreground: 0 0% 98%;
    --card: 240 10% 3.9%;
    --card-foreground: 0 0% 98%;
    --popover: 240 10% 3.9%;
    --popover-foreground: 0 0% 98%;
    --primary: 236 35% 63%;
    --primary-foreground: 240 5.9% 10%;
    --secondary: 240 3.7% 15.9%;
    --secondary-foreground: 0 0% 98%;
    --muted: 240 3.7% 15.9%;
    --muted-foreground: 240 5% 64.9%;
    --accent: 240 3.7% 15.9%;
    --accent-foreground: 0 0% 98%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 0 0% 98%;
    --border: 240 3.7% 15.9%;
    --input: 240 3.7% 15.9%;
    --ring: 236 35% 63%;
  }
}

/* Base Styles */
@layer base {
  * {
    @apply border-border;
  }
  
  html {
    @apply antialiased;
    scroll-behavior: smooth;
  }

  body {
    @apply bg-background text-foreground antialiased min-h-screen overflow-hidden;
    font-family: var(--font-inter), system-ui, sans-serif;
  }

  h1, h2, h3, h4, h5, h6, .font-serif {
    font-family: var(--font-dm-serif), serif;
    letter-spacing: -0.02em;
  }

  /* Selection styles */
  ::selection {
    @apply bg-[#7f85c2]/30 text-white;
  }
}

/* Custom Scrollbar */
@layer utilities {
  .custom-scrollbar {
    scrollbar-width: thin;
    scrollbar-color: rgba(127, 133, 194, 0.3) transparent;
  }

  .custom-scrollbar::-webkit-scrollbar {
    @apply w-1.5;
  }

  .custom-scrollbar::-webkit-scrollbar-track {
    @apply bg-transparent;
  }

  .custom-scrollbar::-webkit-scrollbar-thumb {
    @apply bg-white/20 rounded-full transition-colors hover:bg-white/30;
  }
}

/* Animations */
@keyframes fade-in {
  from { 
    opacity: 0;
    transform: translateY(10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

@keyframes fade-out {
  from {
    opacity: 1;
    transform: translateY(0);
  }
  to {
    opacity: 0;
    transform: translateY(-10px);
  }
}

@keyframes slide-in {
  from {
    transform: translateY(100%);
    opacity: 0;
  }
  to {
    transform: translateY(0);
    opacity: 1;
  }
}

@keyframes pulse-subtle {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.7;
  }
}

@keyframes shimmer {
  0% {
    background-position: -1000px 0;
  }
  100% {
    background-position: 1000px 0;
  }
}

/* Animation Utility Classes */
.animate-fade-in {
  animation: fade-in 0.3s ease-out forwards;
}

.animate-fade-out {
  animation: fade-out 0.3s ease-out forwards;
}

.animate-slide-in {
  animation: slide-in 0.4s cubic-bezier(0.4, 0, 0.2, 1) forwards;
}

.animate-pulse-subtle {
  animation: pulse-subtle 2s ease-in-out infinite;
}

/* Loading Skeleton */
.loading-skeleton {
  @apply relative overflow-hidden bg-white/10 rounded;
}

.loading-skeleton::after {
  @apply absolute inset-0;
  content: '';
  background-image: linear-gradient(
    90deg,
    rgba(255, 255, 255, 0) 0,
    rgba(255, 255, 255, 0.05) 20%,
    rgba(255, 255, 255, 0.1) 60%,
    rgba(255, 255, 255, 0)
  );
  animation: shimmer 2s infinite linear;
}

/* Prose Styles */
.prose {
  @apply max-w-none;
}

.prose h1, .prose h2, .prose h3 {
  @apply text-white font-serif;
}

.prose p {
  @apply text-white/90 leading-relaxed;
}

.prose ul {
  @apply space-y-1 list-disc list-inside;
}

.prose li {
  @apply text-white/90;
}

.prose blockquote {
  @apply border-l-2 border-[#7f85c2] pl-4 py-2 my-4 text-white/90 italic;
}

.prose a {
  @apply text-[#7f85c2] hover:text-[#6b70a3] transition-colors no-underline;
}

.prose strong {
  @apply text-white font-semibold;
}

.prose em {
  @apply text-white/90 italic;
}

/* Background Styles */
body {
  @apply min-h-screen overflow-hidden;
  background-color: #1a1a2e;
}

body::before {
  content: '';
  @apply fixed inset-0;
  background: radial-gradient(
    circle at center,
    rgba(127, 133, 194, 0.15) 0%,
    rgba(26, 26, 46, 0.9) 50%,
    rgba(26, 26, 46, 1) 100%
  );
  z-index: -1;
}

/* Layout Styles */
.layout-container {
  @apply flex flex-col min-h-screen;
}

.main-content {
  @apply flex-grow flex items-center justify-center p-4;
}

.chat-container {
  @apply w-full max-w-4xl mx-auto;
}

/* Transition Utilities */
.custom-transition {
  @apply transition-all duration-200 ease-in-out;
}

.custom-transition-transform {
  @apply transition-transform duration-200 ease-in-out;
}

.custom-transition-opacity {
  @apply transition-opacity duration-200 ease-in-out;
}

/* Focus Styles */
.focus-ring {
  @apply focus:outline-none focus-visible:ring-2 focus-visible:ring-[#7f85c2] focus-visible:ring-offset-2 focus-visible:ring-offset-[#1a1a2e];
}

/* Hover Effects */
.hover-lift {
  @apply transition-transform hover:-translate-y-0.5;
}

.hover-glow {
  @apply transition-shadow hover:shadow-lg hover:shadow-[#7f85c2]/20;
}

/* Mobile Optimizations */
@media (max-width: 640px) {
  .prose {
    @apply text-sm;
  }

  .chat-container {
    @apply p-2;
  }

  .custom-scrollbar::-webkit-scrollbar {
    @apply w-1;
  }
}

/* Print Styles */
@media print {
  .chat-container {
    @apply max-w-none;
  }

  .custom-scrollbar::-webkit-scrollbar {
    @apply hidden;
  }
}

================
File: app/layout.tsx
================
import "./globals.css"
import type { Metadata } from "next"
import { DM_Serif_Text, Inter } from 'next/font/google'

const dmSerifText = DM_Serif_Text({
  subsets: ['latin'],
  weight: ['400'],
  variable: '--font-dm-serif',
})

const inter = Inter({
  subsets: ['latin'],
  variable: '--font-inter',
})

export const metadata: Metadata = {
  title: "Minerva - AAR Assistant",
  description: "AI-powered romance book review chatbot for All About Romance - Find your next great romance read!",
  keywords: "romance books, book reviews, AI chatbot, book recommendations, All About Romance",
  authors: [{ name: "All About Romance" }],
  openGraph: {
    title: "Minerva - AAR Assistant",
    description: "Find your next great romance read with AI-powered book recommendations and reviews.",
    url: "https://allaboutromance.com",
    siteName: "All About Romance",
    type: "website",
  },
  twitter: {
    card: "summary_large_image",
    title: "Minerva - AAR Assistant",
    description: "AI-powered romance book recommendations and reviews",
  },
}

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html 
      lang="en" 
      className={`${dmSerifText.variable} ${inter.variable}`}
      suppressHydrationWarning
    >
      <body className="min-h-screen overflow-hidden bg-[#1a1a2e]">
        <div className="fixed inset-0 bg-[radial-gradient(circle_at_center,rgba(127,133,194,0.15)_0%,rgba(26,26,46,0.9)_50%,rgba(26,26,46,1)_100%)]" />
        <div className="relative h-screen">
          {children}
        </div>
      </body>
    </html>
  )
}

================
File: app/page.tsx
================
import { Suspense } from 'react';

// Loading component for Suspense fallback
function ChatLoading() {
  return (
    <div className="flex min-h-screen items-center justify-center p-4">
      <div className="space-y-4 w-full max-w-2xl">
        <div className="h-8 bg-white/5 rounded animate-pulse" />
        <div className="h-8 bg-white/5 rounded animate-pulse w-3/4" />
      </div>
    </div>
  );
}

// Separate the client component
import dynamic from 'next/dynamic';
const ChatContainer = dynamic(() => import('@/components/ChatContainer'), {
  ssr: false,
  loading: () => <ChatLoading />
});

// Server Component
export default function Home() {
  return (
    <Suspense fallback={<ChatLoading />}>
      <ChatContainer />
    </Suspense>
  );
}

================
File: components/chat/BookReviewCard.tsx
================
import { Badge } from "@/components/ui/badge"
import { Button } from "@/components/ui/button"
import { Card, CardContent } from "@/components/ui/card"
import { BookOpen, Star, ThermometerSun, Tag, ExternalLink } from 'lucide-react'
import { motion } from 'framer-motion'

interface BookReviewCardProps {
  title: string
  author: string
  grade?: string 
  sensuality?: string
  bookTypes?: string[]
  asin?: string
  reviewUrl?: string
  postId?: string
  featuredImage?: string
  reviewTags?: string[]
}

// Grade color mapping with tailwind classes
const gradeColors = {
  'A+': 'bg-emerald-500',
  'A': 'bg-emerald-400',
  'A-': 'bg-emerald-300',
  'B+': 'bg-blue-500',
  'B': 'bg-blue-400',
  'B-': 'bg-blue-300',
  'C+': 'bg-yellow-500',
  'C': 'bg-yellow-400',
  'C-': 'bg-yellow-300',
  'D+': 'bg-orange-500',
  'D': 'bg-orange-400',
  'D-': 'bg-orange-300',
  'F': 'bg-red-500'
} as const;

// Sensuality rating color mapping
const sensualityColors = {
  'Burning': 'bg-red-500/20 text-red-200',
  'Hot': 'bg-orange-500/20 text-orange-200',
  'Warm': 'bg-yellow-500/20 text-yellow-200',
  'Subtle': 'bg-blue-500/20 text-blue-200',
  'Kisses': 'bg-pink-500/20 text-pink-200',
  'None': 'bg-gray-500/20 text-gray-200',
} as const;

export default function BookReviewCard({
  title,
  author,
  grade,
  sensuality,
  bookTypes = [],
  asin,
  reviewUrl,
  postId,
  featuredImage,
  reviewTags = []
}: BookReviewCardProps) {
  const gradeKey = grade as keyof typeof gradeColors;
  const sensualityKey = sensuality as keyof typeof sensualityColors;

  return (
    <motion.div
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      exit={{ opacity: 0, y: -20 }}
      transition={{ 
        duration: 0.5,
        ease: [0.4, 0, 0.2, 1]
      }}
    >
      <Card className="overflow-hidden bg-white/10 backdrop-blur border-white/20 transition-all hover:shadow-lg hover:bg-white/15">
        <CardContent className="p-4">
          <div className="flex gap-4">
            {/* Book Cover Section */}
            <motion.div 
              initial={{ opacity: 0, scale: 0.9 }}
              animate={{ opacity: 1, scale: 1 }}
              transition={{ delay: 0.2 }}
              className="flex-shrink-0"
            >
              {featuredImage ? (
                <div className="relative w-24 h-36 overflow-hidden rounded-lg shadow-md">
                  <img 
                    src={featuredImage} 
                    alt={`Cover of ${title}`} 
                    className="object-cover w-full h-full transition-transform duration-300 hover:scale-110"
                  />
                </div>
              ) : (
                <div className="w-24 h-36 bg-white/5 rounded-lg flex items-center justify-center shadow-md">
                  <BookOpen className="w-8 h-8 text-white/50" />
                </div>
              )}
            </motion.div>
            
            {/* Book Details Section */}
            <div className="flex-1 min-w-0 space-y-3">
              {/* Title and Author */}
              <motion.div
                initial={{ opacity: 0, x: -20 }}
                animate={{ opacity: 1, x: 0 }}
                transition={{ delay: 0.3 }}
              >
                <h3 className="font-serif text-xl leading-tight text-white line-clamp-2 mb-1">{title}</h3>
                <p className="text-white/80 text-sm">by {author}</p>
              </motion.div>

              {/* Grades and Ratings */}
              <motion.div 
                initial={{ opacity: 0, y: 10 }}
                animate={{ opacity: 1, y: 0 }}
                transition={{ delay: 0.4 }}
                className="flex flex-wrap gap-2"
              >
                {grade && (
                  <Badge 
                    className={`${gradeColors[gradeKey] || 'bg-[#7f85c2]/50'} text-white font-medium transition-colors`}
                  >
                    <Star className="w-3 h-3 mr-1 fill-current" />
                    {grade}
                  </Badge>
                )}
                
                {sensuality && (
                  <Badge 
                    variant="secondary" 
                    className={`${sensualityColors[sensualityKey] || 'bg-white/10 text-white'} transition-colors`}
                  >
                    <ThermometerSun className="w-3 h-3 mr-1" />
                    {sensuality}
                  </Badge>
                )}
              </motion.div>

              {/* Book Types and Tags */}
              {(bookTypes.length > 0 || reviewTags.length > 0) && (
                <motion.div 
                  initial={{ opacity: 0, y: 10 }}
                  animate={{ opacity: 1, y: 0 }}
                  transition={{ delay: 0.5 }}
                  className="flex flex-wrap gap-2"
                >
                  {bookTypes.map((type) => (
                    <Badge 
                      key={type} 
                      variant="outline" 
                      className="border-white/20 text-xs text-white/90 bg-white/5"
                    >
                      <Tag className="w-3 h-3 mr-1" />
                      {type}
                    </Badge>
                  ))}
                  {reviewTags.map((tag) => (
                    <Badge 
                      key={tag} 
                      variant="outline" 
                      className="border-white/20 text-xs text-white/80 bg-white/5"
                    >
                      #{tag}
                    </Badge>
                  ))}
                </motion.div>
              )}
              
              {/* Action Buttons */}
              <motion.div 
                initial={{ opacity: 0, y: 10 }}
                animate={{ opacity: 1, y: 0 }}
                transition={{ delay: 0.6 }}
                className="flex flex-wrap gap-2 pt-1"
              >
                {/* Amazon Buy Button */}
                {asin && (
                  <Button 
                    variant="default"
                    size="sm"
                    className="gap-2 bg-[#7f85c2] text-white hover:bg-[#5a5f8f] transition-colors"
                    asChild
                  >
                    <a
                      href={`https://www.amazon.com/gp/product/${asin}/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=${asin}&linkCode=as2&tag=allaboutromance`}
                      target="_blank"
                      rel="noopener noreferrer"
                    >
                      Buy on Amazon
                      <ExternalLink className="w-3 h-3" />
                    </a>
                  </Button>
                )}
                
                {/* Read Review Button */}
                {postId && (
                  <Button 
                    variant="secondary"
                    size="sm"
                    className="gap-2 bg-white/10 text-white hover:bg-white/20 transition-colors"
                    asChild
                  >
                    <a
                      href={`https://allaboutromance.com/?p=${postId}`}
                      target="_blank"
                      rel="noopener noreferrer"
                    >
                      Read Review
                      <ExternalLink className="w-3 h-3" />
                    </a>
                  </Button>
                )}
              </motion.div>
            </div>
          </div>
        </CardContent>
      </Card>
    </motion.div>
  )
}

================
File: components/chat/ChatInput.tsx
================
import { Button } from "@/components/ui/button"
import { Textarea } from "@/components/ui/textarea"
import { useState, useRef, useEffect, KeyboardEvent } from "react"
import { Send } from 'lucide-react'
import { motion, AnimatePresence } from 'framer-motion'
import { cn } from "@/lib/utils"

interface ChatInputProps {
  input: string
  handleInputChange: (e: React.ChangeEvent<HTMLTextAreaElement>) => void
  handleSubmit: (e: React.FormEvent<HTMLFormElement>) => void
  isLoading: boolean
}

export function ChatInput({ 
  input, 
  handleInputChange, 
  handleSubmit, 
  isLoading 
}: ChatInputProps) {
  const textareaRef = useRef<HTMLTextAreaElement>(null)
  const formRef = useRef<HTMLFormElement>(null)
  const [isFocused, setIsFocused] = useState(false)

  // Auto-resize textarea based on content
  useEffect(() => {
    if (textareaRef.current) {
      textareaRef.current.style.height = 'auto'
      textareaRef.current.style.height = `${Math.min(textareaRef.current.scrollHeight, 200)}px`
    }
  }, [input])

  // Focus handling
  const handleFocus = () => setIsFocused(true)
  const handleBlur = () => setIsFocused(false)

  // Handle keyboard shortcuts
  const handleKeyPress = (e: KeyboardEvent<HTMLTextAreaElement>) => {
    // Submit on Enter (without shift)
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault()
      formRef.current?.requestSubmit()
      return
    }

    // New line on Shift + Enter
    if (e.key === 'Enter' && e.shiftKey) {
      return
    }
  }

  // Animation variants
  const formVariants = {
    focused: {
      scale: 1.01,
      transition: {
        type: "spring",
        stiffness: 300,
        damping: 20
      }
    },
    unfocused: {
      scale: 1
    }
  }

  const buttonVariants = {
    disabled: { 
      scale: 0.95,
      opacity: 0.5 
    },
    enabled: { 
      scale: 1,
      opacity: 1 
    },
    tap: { 
      scale: 0.95 
    },
    hover: { 
      scale: 1.05,
      backgroundColor: "rgb(107, 112, 163)" 
    }
  }

  const loadingSpinnerVariants = {
    initial: { rotate: 0 },
    animate: {
      rotate: 360,
      transition: {
        duration: 1,
        ease: "linear",
        repeat: Infinity
      }
    }
  }

  return (
    <motion.form 
      ref={formRef}
      onSubmit={handleSubmit} 
      className="relative flex items-center gap-2"
      variants={formVariants}
      animate={isFocused ? "focused" : "unfocused"}
    >
      <div className="relative flex-1">
        <Textarea
          ref={textareaRef}
          tabIndex={0}
          rows={1}
          value={input}
          onChange={handleInputChange}
          onKeyDown={handleKeyPress}
          onFocus={handleFocus}
          onBlur={handleBlur}
          placeholder="Ask about romance books, reviews, or recommendations..."
          spellCheck={true}
          className={cn(
            "min-h-[44px] w-full resize-none px-4 py-[0.6rem] rounded-lg text-white",
            "placeholder-white/50 transition-all duration-200",
            "border-none focus-visible:ring-1 focus-visible:ring-[#7f85c2]",
            "bg-white/5 hover:bg-white/10 focus:bg-white/10",
            isFocused ? "shadow-lg" : "shadow-none"
          )}
          aria-label="Type your message"
          disabled={isLoading}
        />

        {/* Character limit indicator */}
        <motion.div
          initial={{ opacity: 0 }}
          animate={{ opacity: input.length > 0 ? 1 : 0 }}
          className="absolute bottom-2 right-3 text-xs text-white/50"
        >
          {input.length > 0 && (
            <span>{input.length}/2000</span>
          )}
        </motion.div>
      </div>

      <AnimatePresence mode="wait">
        <motion.div
          variants={buttonVariants}
          initial="disabled"
          animate={isLoading || !input.trim() ? "disabled" : "enabled"}
          whileHover={isLoading || !input.trim() ? undefined : "hover"}
          whileTap={isLoading || !input.trim() ? undefined : "tap"}
        >
          <Button 
            type="submit" 
            size="icon" 
            disabled={isLoading || !input.trim()}
            className={cn(
              "shrink-0 transition-all duration-200",
              "bg-[#7f85c2] text-white hover:bg-[#6b70a3]",
              isLoading || !input.trim() ? "opacity-50 cursor-not-allowed" : "",
              isFocused ? "shadow-md" : "shadow-none"
            )}
          >
            {isLoading ? (
              <motion.div
                role="status"
                className="flex justify-center"
                aria-label="Sending message"
                variants={loadingSpinnerVariants}
                initial="initial"
                animate="animate"
              >
                <div className="h-4 w-4 rounded-full border-2 border-white border-r-transparent" />
                <span className="sr-only">Sending message...</span>
              </motion.div>
            ) : (
              <>
                <Send className="h-4 w-4" />
                <span className="sr-only">Send message</span>
              </>
            )}
          </Button>
        </motion.div>
      </AnimatePresence>
    </motion.form>
  )
}

================
File: components/chat/ChatInterface.tsx
================
import { useRef, useEffect, useState, useCallback } from 'react'
import { ChatInput } from './ChatInput'
import   ChatMessage from './ChatMessage'
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'
import { ScrollArea } from '@/components/ui/scroll-area'
import { Sparkles, ArrowDown } from 'lucide-react'
import { Message } from 'ai'
import { ChangeEvent } from 'react'
import { motion, AnimatePresence } from 'framer-motion'
import { Button } from '@/components/ui/button'

interface ChatInterfaceProps {
  messages: Message[]
  input: string
  handleInputChange: (e: ChangeEvent<HTMLInputElement> | ChangeEvent<HTMLTextAreaElement>) => void
  handleSubmit: (event: React.FormEvent<HTMLFormElement>) => void
  isLoading: boolean
  error?: Error
}

export function ChatInterface({ 
  messages = [], 
  input, 
  handleInputChange, 
  handleSubmit, 
  isLoading, 
  error 
}: ChatInterfaceProps) {
  const messagesEndRef = useRef<HTMLDivElement>(null)
  const scrollAreaRef = useRef<HTMLDivElement>(null)
  const [showScrollButton, setShowScrollButton] = useState(false)
  const [pendingMessage, setPendingMessage] = useState<string | null>(null)

  const conversationStarters = [
    "What did readers think about No Man's Land by Sally Malcolm?",
    "Tell me about A Friend in the Glass by Gregory Ashe",
    "Can you recommend books similar to Murder in Highbury?",
    "What are the latest romance book reviews?",
  ]

  // Filter out raw book data messages
  const displayMessages = messages.filter(m => 
    m.role === 'user' || (m.role === 'assistant' && (!m.content.trim().startsWith('{') || m.content.includes('</book-data>')))
  )

  // Scroll handling
  const handleScroll = useCallback(() => {
    const scrollArea = scrollAreaRef.current
    if (!scrollArea) return

    const { scrollTop, scrollHeight, clientHeight } = scrollArea
    const isNearBottom = scrollHeight - scrollTop - clientHeight < 100
    setShowScrollButton(!isNearBottom)
  }, [])

  useEffect(() => {
    const scrollArea = scrollAreaRef.current
    if (!scrollArea) return

    scrollArea.addEventListener('scroll', handleScroll)
    return () => scrollArea.removeEventListener('scroll', handleScroll)
  }, [handleScroll])

  // Auto-scroll on new messages
  useEffect(() => {
    if (messagesEndRef.current && !showScrollButton) {
      messagesEndRef.current.scrollIntoView({ 
        behavior: displayMessages.length <= 2 ? 'auto' : 'smooth',
        block: 'end'
      })
    }
  }, [displayMessages, showScrollButton])

  // Handle message submission with pending state
  const handleMessageSubmit = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault()
    if (!input.trim() || isLoading) return

    setPendingMessage(input.trim())
    await handleSubmit(event)
    setPendingMessage(null)
  }

  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ 
      behavior: 'smooth',
      block: 'end'
    })
    setShowScrollButton(false)
  }

  return (
    <Card className="flex h-[calc(100vh-2rem)] w-full max-w-4xl mx-auto overflow-hidden rounded-xl border-white/10 bg-white/5 backdrop-blur-md shadow-2xl">
      <div className="flex flex-col w-full">
        <CardHeader className="border-b border-white/10 bg-white/5 px-6">
          <CardTitle className="flex items-center gap-2 text-2xl font-serif">
            <Sparkles className="h-6 w-6 text-[#7f85c2]" />
            <motion.span 
              initial={{ opacity: 0, x: -20 }}
              animate={{ opacity: 1, x: 0 }}
              className="bg-gradient-to-r from-white to-white/80 bg-clip-text text-transparent"
            >
              Minerva - AAR Assistant
            </motion.span>
          </CardTitle>
        </CardHeader>

        <CardContent className="flex-1 overflow-hidden p-4">
          <ScrollArea 
            className="h-full pr-4 custom-scrollbar" 
            ref={scrollAreaRef}
          >
            <AnimatePresence mode="wait">
              {displayMessages.length === 0 ? (
                <motion.div
                  initial={{ opacity: 0, y: 20 }}
                  animate={{ opacity: 1, y: 0 }}
                  exit={{ opacity: 0, y: -20 }}
                  transition={{ duration: 0.5 }}
                  className="flex flex-col items-center justify-center h-full text-center space-y-4 p-4"
                >
                  <p className="text-xl font-medium font-serif text-white">
                    Welcome to All About Romance!
                  </p>
                  <p className="text-sm text-white/80 mb-4">
                    Ask me about romance books, reviews, or get personalized recommendations.
                  </p>
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-3 w-full max-w-2xl">
                    {conversationStarters.map((starter, index) => (
                      <motion.button
                        key={index}
                        initial={{ opacity: 0, y: 20 }}
                        animate={{ opacity: 1, y: 0 }}
                        whileHover={{ scale: 1.02 }}
                        whileTap={{ scale: 0.98 }}
                        transition={{ 
                          duration: 0.3, 
                          delay: index * 0.1,
                          type: "spring",
                          stiffness: 300
                        }}
                        onClick={() => {
                          handleInputChange({ target: { value: starter } } as ChangeEvent<HTMLInputElement>)
                          handleMessageSubmit({ preventDefault: () => {} } as React.FormEvent<HTMLFormElement>)
                        }}
                        className="p-4 text-left rounded-lg bg-white/5 hover:bg-white/10 transition-colors text-sm text-white/90 border border-white/10"
                      >
                        {starter}
                      </motion.button>
                    ))}
                  </div>
                </motion.div>
              ) : (
                <div className="space-y-6 py-4">
                  <AnimatePresence mode="popLayout" initial={false}>
                    {displayMessages.map((message, index) => (
                      <motion.div
                        key={message.id || index}
                        initial={{ opacity: 0, y: 20 }}
                        animate={{ opacity: 1, y: 0 }}
                        exit={{ opacity: 0, y: -20 }}
                        transition={{ 
                          duration: 0.4,
                          type: "spring",
                          damping: 20
                        }}
                      >
                        <ChatMessage
                          message={message}
                          isLoading={isLoading && index === displayMessages.length - 1}
                        />
                      </motion.div>
                    ))}

                    {/* Pending message animation */}
                    {pendingMessage && (
                      <motion.div
                        key="pending"
                        initial={{ opacity: 0, y: 20 }}
                        animate={{ opacity: 1, y: 0 }}
                        exit={{ opacity: 0, y: -20 }}
                        transition={{ duration: 0.3 }}
                      >
                        <ChatMessage
                          message={{ role: 'user', content: pendingMessage, id: 'pending' }}
                          isLoading={false}
                        />
                      </motion.div>
                    )}
                  </AnimatePresence>
                  <div ref={messagesEndRef} />
                </div>
              )}
            </AnimatePresence>
          </ScrollArea>

          {/* Scroll to bottom button */}
          <AnimatePresence>
            {showScrollButton && (
              <motion.div
                initial={{ opacity: 0, y: 20 }}
                animate={{ opacity: 1, y: 0 }}
                exit={{ opacity: 0, y: 20 }}
                transition={{ duration: 0.2 }}
                className="absolute bottom-24 right-6"
              >
                <Button
                  onClick={scrollToBottom}
                  size="sm"
                  className="bg-[#7f85c2] text-white hover:bg-[#6b70a3] transition-colors rounded-full shadow-lg px-4 py-2 flex items-center gap-2"
                >
                  <ArrowDown className="w-4 h-4" />
                  <span className="text-sm">New messages</span>
                </Button>
              </motion.div>
            )}
          </AnimatePresence>
        </CardContent>

        <div className="p-4 border-t border-white/10 bg-white/5">
          <ChatInput
            input={input}
            handleInputChange={handleInputChange}
            handleSubmit={handleMessageSubmit}
            isLoading={isLoading}
          />
        </div>
      </div>
    </Card>
  )
}

================
File: components/chat/ChatMessage.tsx
================
'use client';

import { Message } from "ai";
import { cn } from "@/lib/utils";
import { Avatar } from "../ui/avatar";
import { Bot, User } from 'lucide-react';
import { useEffect, useState, memo, useRef } from "react";
import BookReviewCard from "./BookReviewCard";
import { Book } from "@/lib/validators/book-data";

// Constants
const ResponseStartMarker = '---RESPONSE-START---';

interface ProcessedContent {
  books: Book[];
  content: string;
  error?: string;
}

interface ChatMessageProps {
  message: Message;
  isLoading?: boolean;
}

const ChatMessage = memo(({ message, isLoading }: ChatMessageProps) => {
  // Track if content has been processed and is ready to display
  const [isReady, setIsReady] = useState(false);
  const [processedContent, setProcessedContent] = useState<ProcessedContent | null>(null);
  const contentReadyRef = useRef<NodeJS.Timeout>();

  useEffect(() => {
    if (!message.content) return;

    // Clear any existing timeout
    if (contentReadyRef.current) {
      clearTimeout(contentReadyRef.current);
    }

    // Reset states when content changes
    setIsReady(false);
    
    try {
      // For user messages, process immediately
      if (message.role === 'user') {
        setProcessedContent({ books: [], content: message.content, error: undefined });
        setIsReady(true);
        return;
      }

      // For assistant messages, clean and process content
      const cleanedContent = cleanResponseContent(message.content);
      const result = processMessageContent(cleanedContent);

      if (!isLoading) {
        setProcessedContent(result);
        // Small delay before showing content to ensure smooth transition
        contentReadyRef.current = setTimeout(() => setIsReady(true), 100);
      }
    } catch (error) {
      console.error('Error processing message:', error);
      setProcessedContent({
        books: [],
        content: message.content,
        error: 'Failed to process message content'
      });
      setIsReady(true);
    }

    // Cleanup timeout on unmount or content change
    return () => {
      if (contentReadyRef.current) {
        clearTimeout(contentReadyRef.current);
      }
    };
  }, [message.content, message.role, isLoading]);

  // Don't render anything while content is being processed
  if (!isReady && message.role === 'assistant') {
    return null;
  }

  return (
    <div
      className={cn(
        "group relative flex items-start gap-4 w-full",
        message.role === "user" ? "justify-end" : "justify-start"
      )}
    >
      <div className={cn(
        "flex gap-4 items-start",
        message.role === "user" ? "ml-auto flex-row-reverse" : "flex-row"
      )}>
        <Avatar className="h-8 w-8 flex-shrink-0">
          <div className={cn(
            "flex h-full w-full items-center justify-center rounded-full",
            message.role === "user" ? "bg-white/10" : "bg-[#7f85c2] text-white"
          )}>
            {message.role === "user" ? (
              <User className="h-4 w-4 text-white" />
            ) : (
              <Bot className="h-4 w-4" />
            )}
          </div>
        </Avatar>

        <div className={cn(
          "flex flex-col gap-4 rounded-lg px-4 py-3",
          message.role === "user"
            ? "bg-[#7f85c2] text-white self-end w-fit max-w-[85%]"
            : "bg-white/5 backdrop-blur text-white min-w-[200px] max-w-[85%]"
        )}>
          {message.role === "user" ? (
            <div className="text-sm whitespace-pre-wrap break-words">
              {message.content}
            </div>
          ) : processedContent && (
            <div className="space-y-6">
              {/* Book Cards Section */}
              <div className="space-y-4">
                {processedContent.books?.map((book, index) => (
                  <div key={`${book.title}-${book.author}-${index}`}>
                    <BookReviewCard {...book} />
                  </div>
                ))}
              </div>

              {/* Text Content Section */}
              {processedContent.content && (
                <div className="prose prose-invert max-w-none">
                  <div 
                    className="text-base space-y-4"
                    dangerouslySetInnerHTML={{ 
                      __html: processHTMLContent(processedContent.content)
                    }}
                  />
                </div>
              )}

              {/* Error Message */}
              {processedContent.error && (
                <div className="text-red-400 text-sm italic bg-red-500/10 px-4 py-2 rounded-md">
                  {processedContent.error}
                </div>
              )}
            </div>
          )}
        </div>
      </div>
    </div>
  );
});

ChatMessage.displayName = "ChatMessage";

function cleanResponseContent(content: string): string {
  const markerIndex = content.indexOf(ResponseStartMarker);
  
  if (markerIndex === -1) {
    return content;
  }

  return content
    .substring(markerIndex + ResponseStartMarker.length)
    .trim();
}

function processMessageContent(content: string): ProcessedContent {
  const result: ProcessedContent = {
    books: [],
    content: ''
  };

  try {
    const bookDataRegex = /<book-data>\s*({[\s\S]*?})\s*<\/book-data>/g;
    let processedContent = content;
    let match;

    while ((match = bookDataRegex.exec(content)) !== null) {
      try {
        const jsonStr = match[1]
          .replace(/\{\{(\{+)?/g, '{')
          .replace(/\}\}(\}+)?/g, '}')
          .trim();
        
        const bookData = JSON.parse(jsonStr);

        if (bookData.books && Array.isArray(bookData.books)) {
          const validBooks = bookData.books
          .map((book: any) => ({
              title: book.title?.trim() || '',
              author: book.author?.trim() || '',
              grade: book.grade?.trim() || '',
              sensuality: book.sensuality?.trim() || '',
              bookTypes: Array.isArray(book.bookTypes)
                ? book.bookTypes.map((t: string) => t.trim())
                : typeof book.bookTypes === 'string'
                ? [book.bookTypes.trim()]
                : [],
              asin: book.asin?.trim() || '',
              reviewUrl: book.reviewUrl?.trim() || '',
              postId: book.postId?.trim() || '',
              featuredImage: book.featuredImage?.trim() || ''
            }))
            .filter((book: Book) => book.title && book.author);

          result.books.push(...validBooks);
        }

        processedContent = processedContent.replace(match[0], '');
      } catch (error) {
        console.error('Error parsing book data:', error);
      }
    }

    result.content = processedContent
      .replace(/^\s*$/gm, '')
      .replace(/\n{3,}/g, '\n\n')
      .trim();
    
  } catch (error) {
    console.error('Error processing message content:', error);
    result.error = 'Failed to process message content';
  }

  return result;
}

function processHTMLContent(content: string): string {
  return content
    .replace(
      /^###\s(.+)$/gm, 
      '<h3 class="text-lg font-serif font-medium text-white/90 mt-6 mb-3">$1</h3>'
    )
    .replace(
      /^##\s(.+)$/gm, 
      '<h2 class="text-xl font-serif font-medium text-white mt-6 mb-3">$1</h2>'
    )
    .replace(
      /^#\s(.+)$/gm, 
      '<h1 class="text-2xl font-serif font-medium text-white mt-6 mb-4 leading-tight">$1</h1>'
    )
    .replace(
      /^[•\*]\s(.+)$/gm, 
      '<li class="flex items-center gap-3 text-white/90"><span class="text-[#7f85c2]">•</span><span>$1</span></li>'
    )
    .replace(
      /(<li>.*<\/li>\n?)+/g, 
      '<ul class="space-y-2 my-3 list-none">$&</ul>'
    )
    .replace(
      /\*\*([^*]+)\*\*/g, 
      '<strong class="text-white font-medium">$1</strong>'
    )
    .replace(
      /\*([^*]+)\*/g, 
      '<span class="text-white/90">$1</span>'
    )
    .replace(
      /\[([^\]]+)\]\(([^)]+)\)/g, 
      '<a href="$2" target="_blank" rel="noopener noreferrer" class="text-[#7f85c2] hover:text-[#9da3d4] hover:underline transition-colors">$1</a>'
    )
    .replace(
      /^\>\s*(.+)$/gm, 
      '<blockquote class="border-l-2 border-[#7f85c2] pl-4 py-2 my-4 text-white/90 italic bg-white/5 rounded-r">$1</blockquote>'
    )
    .replace(/\n{3,}/g, '\n\n')
    .split('\n\n')
    .map(p => {
      if (!p.trim()) return '';
      if (p.startsWith('<')) return p;
      return `<p class="text-white/90 leading-relaxed mb-3">${p.trim()}</p>`;
    })
    .filter(Boolean)
    .join('\n');
}

export default ChatMessage;

================
File: components/ui/avatar.tsx
================
"use client"

import * as React from "react"
import * as AvatarPrimitive from "@radix-ui/react-avatar"

import { cn } from "@/lib/utils"

const Avatar = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Root
    ref={ref}
    className={cn(
      "relative flex h-10 w-10 shrink-0 overflow-hidden rounded-full",
      className
    )}
    {...props}
  />
))
Avatar.displayName = AvatarPrimitive.Root.displayName

const AvatarImage = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Image>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Image>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Image
    ref={ref}
    className={cn("aspect-square h-full w-full", className)}
    {...props}
  />
))
AvatarImage.displayName = AvatarPrimitive.Image.displayName

const AvatarFallback = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Fallback>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Fallback>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Fallback
    ref={ref}
    className={cn(
      "flex h-full w-full items-center justify-center rounded-full bg-muted",
      className
    )}
    {...props}
  />
))
AvatarFallback.displayName = AvatarPrimitive.Fallback.displayName

export { Avatar, AvatarImage, AvatarFallback }

================
File: components/ui/badge.tsx
================
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const badgeVariants = cva(
  "inline-flex items-center rounded-md border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground shadow hover:bg-primary/80",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive:
          "border-transparent bg-destructive text-destructive-foreground shadow hover:bg-destructive/80",
        outline: "text-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, ...props }: BadgeProps) {
  return (
    <div className={cn(badgeVariants({ variant }), className)} {...props} />
  )
}

export { Badge, badgeVariants }

================
File: components/ui/button.tsx
================
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground shadow-sm hover:bg-destructive/90",
        outline:
          "border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground shadow-sm hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2",
        sm: "h-8 rounded-md px-3 text-xs",
        lg: "h-10 rounded-md px-8",
        icon: "h-9 w-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button"
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    )
  }
)
Button.displayName = "Button"

export { Button, buttonVariants }

================
File: components/ui/card.tsx
================
import * as React from "react"

import { cn } from "@/lib/utils"

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-xl border bg-card text-card-foreground shadow",
      className
    )}
    {...props}
  />
))
Card.displayName = "Card"

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
))
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("font-semibold leading-none tracking-tight", className)}
    {...props}
  />
))
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
))
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
))
CardFooter.displayName = "CardFooter"

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }

================
File: components/ui/input.tsx
================
import * as React from "react"

import { cn } from "@/lib/utils"

const Input = React.forwardRef<HTMLInputElement, React.ComponentProps<"input">>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-9 w-full rounded-md border border-input bg-transparent px-3 py-1 text-base shadow-sm transition-colors file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Input.displayName = "Input"

export { Input }

================
File: components/ui/scroll-area.tsx
================
"use client"

import * as React from "react"
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area"

import { cn } from "@/lib/utils"

const ScrollArea = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <ScrollAreaPrimitive.Root
    ref={ref}
    className={cn("relative overflow-hidden", className)}
    {...props}
  >
    <ScrollAreaPrimitive.Viewport className="h-full w-full rounded-[inherit]">
      {children}
    </ScrollAreaPrimitive.Viewport>
    <ScrollBar />
    <ScrollAreaPrimitive.Corner />
  </ScrollAreaPrimitive.Root>
))
ScrollArea.displayName = ScrollAreaPrimitive.Root.displayName

const ScrollBar = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>
>(({ className, orientation = "vertical", ...props }, ref) => (
  <ScrollAreaPrimitive.ScrollAreaScrollbar
    ref={ref}
    orientation={orientation}
    className={cn(
      "flex touch-none select-none transition-colors",
      orientation === "vertical" &&
        "h-full w-2.5 border-l border-l-transparent p-[1px]",
      orientation === "horizontal" &&
        "h-2.5 flex-col border-t border-t-transparent p-[1px]",
      className
    )}
    {...props}
  >
    <ScrollAreaPrimitive.ScrollAreaThumb className="relative flex-1 rounded-full bg-border" />
  </ScrollAreaPrimitive.ScrollAreaScrollbar>
))
ScrollBar.displayName = ScrollAreaPrimitive.ScrollAreaScrollbar.displayName

export { ScrollArea, ScrollBar }

================
File: components/ui/textarea.tsx
================
import * as React from "react"

import { cn } from "@/lib/utils"

const Textarea = React.forwardRef<
  HTMLTextAreaElement,
  React.ComponentProps<"textarea">
>(({ className, ...props }, ref) => {
  return (
    <textarea
      className={cn(
        "flex min-h-[60px] w-full rounded-md border border-input bg-transparent px-3 py-2 text-base shadow-sm placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        className
      )}
      ref={ref}
      {...props}
    />
  )
})
Textarea.displayName = "Textarea"

export { Textarea }

================
File: components/ChatContainer.tsx
================
'use client';

import { useState, useEffect, useCallback, useRef } from 'react';
import { type Message } from 'ai';
import { readStreamableValue } from 'ai/rsc';
import { Toaster, toast } from 'sonner';
import { continueConversation } from '@/app/actions';
import { ChatInterface } from '@/components/chat/ChatInterface';
import { usePathname, useRouter, useSearchParams } from 'next/navigation';

const MAX_RETRIES = 3;
const RETRY_DELAY = 1000; // 1 second
const MESSAGE_TIMEOUT = 30000; // 30 seconds
const MAX_CONVERSATION_LENGTH = 20;

interface ChatError extends Error {
  message: string;
}

export default function ChatContainer() {
  const [mounted, setMounted] = useState(false);
  const [conversation, setConversation] = useState<Message[]>([]);
  const [input, setInput] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const abortController = useRef<AbortController | null>(null);
  const timeoutRef = useRef<NodeJS.Timeout | null>(null);
  const retryCountRef = useRef(0);

  const router = useRouter();
  const pathname = usePathname();
  const searchParams = useSearchParams();

  // Initialize component
  useEffect(() => {
    setMounted(true);
    return () => {
      if (timeoutRef.current) clearTimeout(timeoutRef.current);
      if (abortController.current) abortController.current.abort();
    };
  }, []);

  // Share conversation handler
  const handleShareConversation = useCallback(() => {
    const shareableMessages = conversation.map(msg => ({
      role: msg.role,
      content: msg.content
    }));
    
    const shareUrl = new URL(window.location.href);
    shareUrl.searchParams.set('messages', JSON.stringify(shareableMessages));
    
    navigator.clipboard.writeText(shareUrl.toString())
      .then(() => toast.success('Conversation link copied to clipboard!'))
      .catch(() => toast.error('Failed to copy conversation link'));
  }, [conversation]);

  // Load shared conversation
  useEffect(() => {
    if (!mounted || !searchParams) return;

    const messagesParam = searchParams.get('messages');
    if (messagesParam) {
      try {
        const sharedMessages = JSON.parse(messagesParam) as Message[];
        setConversation(sharedMessages.map((msg, index) => ({
          ...msg,
          id: `shared-${index}`
        })));
      } catch (error) {
        console.error('Error loading shared conversation:', error);
        toast.error('Failed to load shared conversation');
      }
    }
  }, [mounted, searchParams]);

  // Handle message sending with retries and timeout
  const handleSend = async (content: string, retryCount = 0) => {
    try {
      setIsLoading(true);
      
      if (abortController.current) {
        abortController.current.abort();
      }
      
      abortController.current = new AbortController();

      timeoutRef.current = setTimeout(() => {
        if (abortController.current) {
          abortController.current.abort();
          throw new Error('Response timeout');
        }
      }, MESSAGE_TIMEOUT);

      if (conversation.length >= MAX_CONVERSATION_LENGTH) {
        toast.warning('Conversation limit reached. Starting new conversation.');
        setConversation([]);
      }

      const newUserMessage: Message = { 
        role: 'user', 
        content, 
        id: Date.now().toString() 
      };

      const newConversation = [...conversation, newUserMessage];
      setConversation(newConversation);
      setInput('');

      const { messages, newMessage } = await continueConversation(newConversation);
      
      let textContent = '';
      let lastUpdate = Date.now();

      for await (const delta of readStreamableValue(newMessage)) {
        textContent = `${textContent}${delta}`;
        const currentTime = Date.now();
        
        if (currentTime - lastUpdate > 100) {
          setConversation([
            ...messages,
            { 
              role: 'assistant', 
              content: textContent, 
              id: 'response-' + Date.now() 
            }
          ]);
          lastUpdate = currentTime;
        }
      }

      setConversation([
        ...messages,
        { 
          role: 'assistant', 
          content: textContent, 
          id: 'response-' + Date.now() 
        }
      ]);

      retryCountRef.current = 0;

    } catch (error) {
      console.error('Error in chat:', error);
      const chatError = error as ChatError;

      if (retryCount < MAX_RETRIES && chatError.message !== 'Aborted') {
        retryCountRef.current = retryCount + 1;
        toast.error(`Connection error. Retrying... (${retryCount + 1}/${MAX_RETRIES})`);
        
        setTimeout(() => {
          handleSend(content, retryCount + 1);
        }, RETRY_DELAY * Math.pow(2, retryCount));
        
        return;
      }

      if (chatError.message === 'Response timeout') {
        toast.error('Response took too long. Please try again.');
      } else if (chatError.message === 'Aborted') {
        toast.info('Request cancelled.');
      } else {
        toast.error('Failed to get response. Please try again.');
      }

      setConversation(prev => prev.slice(0, -1));

    } finally {
      setIsLoading(false);
      if (timeoutRef.current) clearTimeout(timeoutRef.current);
      abortController.current = null;
    }
  };

  if (!mounted) return null;

  return (
    <div className="flex min-h-screen items-center justify-center p-4">
      <Toaster 
        position="top-center" 
        richColors 
        closeButton
        duration={3000}
      />
      
      <ChatInterface 
        messages={conversation}
        input={input}
        handleInputChange={(e) => setInput(e.target.value)}
        handleSubmit={(e) => {
          e.preventDefault();
          if (!input.trim() || isLoading) return;
          handleSend(input.trim());
        }}
        isLoading={isLoading}
      />
    </div>
  );
}

================
File: lib/services/chat.ts
================
import { ChatOpenAI } from '@langchain/openai';
import { StringOutputParser } from '@langchain/core/output_parsers';
import { ChatPromptTemplate, MessagesPlaceholder } from '@langchain/core/prompts';
import { RunnableSequence } from '@langchain/core/runnables';
import { Message } from 'ai';
import { pineconeService } from './pinecone';
import { HumanMessage, AIMessage, BaseMessage } from '@langchain/core/messages';

// Enhanced interfaces for type safety
interface Comment {
  author: string;
  content: string;
}

interface ReviewMetadata {
  bookTitle?: string;
  authorName?: string;
  grade?: string;
  sensuality?: string;
  bookTypes?: string[];
  commentAuthors?: string[];
  commentContents?: string[];
  asin?: string;
  url?: string;
  postId?: string;
  featuredImage?: string;
  reviewerName?: string;
  publishDate?: string;
  text?: string;
}

interface BookData {
  title: string;
  author: string;
  grade: string | null;
  sensuality: string | null;
  bookTypes: string[];
  asin: string | null;
  reviewUrl: string | null;
  postId: string | null;
  featuredImage: string | null;
  reviewerName: string | null;
  publishDate: string | null;
  comments: Comment[] | null;
  reviewContent: string | null;
}

interface ProcessedMetadata {
  [key: string]: BookData;
}

// Query Types for optimizing retrieval and response
type QueryType = 
  | 'RECOMMENDATION'
  | 'LATEST_REVIEWS'
  | 'READER_FEEDBACK'
  | 'BOOK_ANALYSIS'
  | 'TREND_ANALYSIS'
  | 'GENERAL';

// Constants for response optimization
const MAX_BOOKS_PER_RESPONSE = {
  RECOMMENDATION: 3,
  LATEST_REVIEWS: 4,
  READER_FEEDBACK: 1,
  BOOK_ANALYSIS: 1,
  TREND_ANALYSIS: 4,
  GENERAL: 2
};

const RETRIEVAL_COUNT = {
  RECOMMENDATION: 6,
  LATEST_REVIEWS: 6,
  READER_FEEDBACK: 3,
  BOOK_ANALYSIS: 2,
  TREND_ANALYSIS: 8,
  GENERAL: 4
};

const BOOK_DATA_TEMPLATE = `{{
  "books": [
    {{
      "title": string,
      "author": string,
      "grade": string | null,
      "sensuality": string | null,
      "bookTypes": string[],
      "asin": string | null,
      "reviewUrl": string | null,
      "postId": string | null,
      "featuredImage": string | null,
      "reviewerName": string | null,
      "publishDate": string | null,
      "reviewContent": string | null,
      "comments": Array<{{
        author: string,
        content: string
       }}> | null
    }}
  ]
}}`;

const SYSTEM_TEMPLATE = `You are Minerva, an AI assistant for All About Romance (AAR). Help users discover great romance books through AAR's reviews.

CRITICAL RULES:
1. ONLY recommend books that exist in the provided metadata. Never invent or hallucinate books.
2. ALL book information must be directly from the metadata, no exceptions.
3. Limit book recommendations based on query type.
4. Never repeat book information that's already shown in book cards.
5. Keep responses concise and focused.
6. Always cite reader comments when discussing feedback.

VERY IMPORTANT FORMAT RULES:
- Start responses with ---RESPONSE-START---
- No asterisks (*) for emphasis 
- No markdown at start of response
- Begin with book-data block, then natural response

Response Structure:

1. Book Data Format (REQUIRED):
<book-data>
${BOOK_DATA_TEMPLATE}
</book-data>

2. For BOOK REVIEWS:
# [Title] by [Author]

## Review Overview
• Key themes and elements
• Notable aspects
• Reader reception

[If comments exist:]
## Reader Opinions
• Direct quotes with context

3. For RECOMMENDATIONS:
# Suggested Books
[Focus on WHY these specific books match the request]

4. For TRENDS/ANALYSIS:
# Analysis
- Present clear statistics (e.g., "2 out of 5 books", "40% of recent reviews")
- Compare specific metrics (grades, sensuality, genres)
- Note data limitations (e.g., "Based on X available reviews")
- Include time-based patterns when relevant
- Support trends with specific examples
- Identify notable outliers or exceptions

Remember for trends:
- Use exact numbers from available data
- Compare across relevant categories
- Note sample size limitations
- Focus on measurable patterns
- Cite specific examples to support trends

Remember:
- Only include books that are DIRECTLY relevant
- Focus on quality over quantity
- Be specific about why books are recommended
- Use reader comments to support points
- Keep formatting clean and consistent

Available metadata: {metadata}
Context: {context}
Human: {question}
Assistant: Analyzing your request to provide relevant recommendations:`;

export class ChatService {
  private llm: ChatOpenAI;
  
  constructor() {
    this.llm = new ChatOpenAI({
      modelName: "gpt-4o-mini",
      temperature: 0.5, // Reduced for more consistent outputs
      streaming: true,
      maxTokens: 1500,
      timeout: 60000
    });
  }

  private classifyQuery(query: string): QueryType {
    const normalizedQuery = query.toLowerCase();
    
    if (normalizedQuery.includes('similar') || 
        normalizedQuery.includes('like') || 
        normalizedQuery.includes('recommend')) {
      return 'RECOMMENDATION';
    }
    
    if (normalizedQuery.includes('latest') || 
        normalizedQuery.includes('recent') || 
        normalizedQuery.includes('new')) {
      return 'LATEST_REVIEWS';
    }
    
    if (normalizedQuery.includes('think') || 
        normalizedQuery.includes('opinion') || 
        normalizedQuery.includes('feedback') ||
        normalizedQuery.includes('comments')) {
      return 'READER_FEEDBACK';
    }
    
    if (normalizedQuery.includes('compare') || 
        normalizedQuery.includes('analysis') || 
        normalizedQuery.includes('explain')) {
      return 'BOOK_ANALYSIS';
    }
    
    if (normalizedQuery.includes('trend') || 
        normalizedQuery.includes('pattern') || 
        normalizedQuery.includes('across') ||
        normalizedQuery.includes('ratings') ||
        normalizedQuery.includes('grades') ||
        normalizedQuery.includes('sensuality') ||
        normalizedQuery.includes('compare')) {
      return 'TREND_ANALYSIS';
    }
    
    return 'GENERAL';
  }

  private formatChatHistory(messages: Message[]): BaseMessage[] {
    return messages.slice(-5).map(m => 
      m.role === 'user' 
        ? new HumanMessage(m.content) 
        : new AIMessage(m.content)
    );
  }

  private formatContext(context: string): string {
    return context
      .trim()
      .split('\n')
      .filter(line => line.length > 0 && !line.startsWith('Tags:'))
      .join('\n');
  }

  private validateBookMetadata(bookData: BookData): boolean {
    return !!(
      bookData.title &&
      bookData.author &&
      (bookData.grade || bookData.sensuality || bookData.bookTypes.length > 0)
    );
  }

  private extractBookMetadata(docs: any[]): ProcessedMetadata {
    return docs.reduce((acc: ProcessedMetadata, doc) => {
      const metadata = doc.metadata as ReviewMetadata;
      if (!metadata?.bookTitle || !metadata?.authorName) return acc;

      const key = `${metadata.bookTitle}-${metadata.authorName}`;
      
      const validComments: Comment[] = (metadata.commentContents || [])
        .map((content: string, index: number) => ({
          author: metadata.commentAuthors?.[index]?.trim() || '',
          content: content?.trim() || ''
        }))
        .filter((c: Comment) => c.author && c.content);

      const bookData = {
        title: metadata.bookTitle.trim(),
        author: metadata.authorName.trim(),
        grade: metadata.grade?.trim() || null,
        sensuality: metadata.sensuality?.trim() || null,
        bookTypes: Array.isArray(metadata.bookTypes) 
          ? metadata.bookTypes.map((t: string) => t.trim())
          : [],
        asin: metadata.asin?.trim() || null,
        reviewUrl: metadata.url?.trim() || null,
        postId: metadata.postId?.trim() || null,
        featuredImage: metadata.featuredImage?.trim() || null,
        reviewerName: metadata.reviewerName?.trim() || null,
        publishDate: metadata.publishDate?.trim() || null,
        comments: validComments.length > 0 ? validComments : null,
        reviewContent: metadata.text?.trim() || null
      };

      // Only add valid book entries
      if (this.validateBookMetadata(bookData)) {
        acc[key] = bookData;
      }

      return acc;
    }, {});
  }

  async processMessage(messages: Message[]) {
    const latestMessage = messages[messages.length - 1];
    
    try {
      const queryType = this.classifyQuery(latestMessage.content);
      const retrievalCount = RETRIEVAL_COUNT[queryType];
      
      const relevantDocs = await pineconeService.getRelevantReviews(
        latestMessage.content,
        retrievalCount
      );
      
      const bookMetadata = this.extractBookMetadata(relevantDocs);
      
      // Enhance context based on query type
      const context = relevantDocs
        .map(doc => doc.pageContent)
        .filter(Boolean)
        .join('\n\n');

      const prompt = ChatPromptTemplate.fromMessages([
        ["system", SYSTEM_TEMPLATE],
        new MessagesPlaceholder("chat_history"),
        ["human", "{question}"],
      ]);

      const chain = RunnableSequence.from([
        {
          question: (input: string) => input,
          context: () => this.formatContext(context),
          chat_history: () => this.formatChatHistory(messages.slice(0, -1)),
          metadata: () => JSON.stringify({
            books: bookMetadata,
            maxBooks: MAX_BOOKS_PER_RESPONSE[queryType],
            queryType
          }, null, 2)
        },
        prompt,
        this.llm,
        new StringOutputParser()
      ]);

      const stream = await chain.stream(latestMessage.content);
      return stream;

    } catch (error) {
      console.error('Error in chat chain:', error);
      throw error;
    }
  }
}

export const chatService = new ChatService();

================
File: lib/services/pinecone.ts
================
import { Pinecone } from '@pinecone-database/pinecone';
import { OpenAIEmbeddings } from '@langchain/openai';
import { PineconeStore } from '@langchain/pinecone';
import { Document } from '@langchain/core/documents';
import { ReviewMetadata, formatReviewMetadata } from '../validators/book-data';

export class PineconeService {
  private pinecone: Pinecone;
  private embeddings: OpenAIEmbeddings;
  private indexName: string;

  constructor() {
    this.pinecone = new Pinecone();
    this.embeddings = new OpenAIEmbeddings({
      modelName: "text-embedding-3-small"
    });
    this.indexName = process.env.PINECONE_INDEX_NAME!;
  }

  async getVectorStore() {
    const pineconeIndex = this.pinecone.Index(this.indexName);
    return await PineconeStore.fromExistingIndex(this.embeddings, {
      pineconeIndex
    });
  }

  async getRelevantReviews(query: string, k: number = 4): Promise<Document[]> {
    const vectorStore = await this.getVectorStore();
    const retriever = vectorStore.asRetriever(k);
    
    try {
      return await retriever.getRelevantDocuments(query);
    } catch (error) {
      console.error('Error retrieving documents:', error);
      return [];
    }
  }

  async addReview(review: ReviewMetadata) {
    const vectorStore = await this.getVectorStore();
    const metadata = formatReviewMetadata(review);
    
    // Create document with review content and metadata
    // Format the review content in a structured way
    const pageContent = `
Book Review: ${review.title} by ${review.authorName}
${review.grade ? `Grade: ${review.grade}` : ''}
${review.sensuality ? `Sensuality Rating: ${review.sensuality}` : ''}
${review.bookTypes?.length ? `Categories: ${review.bookTypes.join(', ')}` : ''}
${review.reviewAuthor ? `Reviewed by: ${review.reviewAuthor}` : ''}

Review:
${review.content}

${review.comments?.length ? `Reader Comments:\n${review.comments.map(c => 
  `${c.author} says: ${c.content}`
).join('\n')}` : ''}`.trim();

    const doc = new Document({
      pageContent,
      metadata
    });

    try {
      await vectorStore.addDocuments([doc]);
      return true;
    } catch (error) {
      console.error('Error adding document:', error);
      return false;
    }
  }

  async deleteReview(postId: string) {
    const pineconeIndex = this.pinecone.Index(this.indexName);
    try {
      await pineconeIndex.deleteOne(postId);
      return true;
    } catch (error) {
      console.error('Error deleting document:', error);
      return false;
    }
  }
}

export const pineconeService = new PineconeService();

================
File: lib/validators/book-data.ts
================
import { z } from 'zod';

// Review metadata for Pinecone
export const ReviewMetadataSchema = z.object({
  postId: z.string().optional(),
  title: z.string(),
  authorName: z.string(),
  permalink: z.string().url().optional(),
  featuredImage: z.string().url().optional(),
  excerpt: z.string().optional(),
  content: z.string(),
  grade: z.string().optional(),
  sensuality: z.string().optional(),
  bookTypes: z.array(z.string()).optional(),
  reviewTags: z.array(z.string()).optional(),
  amazonLinks: z.array(z.string().url()).optional(),
  asin: z.string().optional(),
  publishDate: z.string().optional(),
  reviewAuthor: z.string().optional(),
  comments: z.array(z.object({
    author: z.string(),
    content: z.string(),
    date: z.string()
  })).optional()
});

// Book schema for chat responses
export const BookSchema = z.object({
  title: z.string(),
  author: z.string(),
  grade: z.string().optional(),
  sensuality: z.string().optional(),
  bookTypes: z.array(z.string()).optional(),
  asin: z.string().optional(),
  reviewUrl: z.string().url().optional(),
  postId: z.string().optional(),
  featuredImage: z.string().url().optional(),
  excerpt: z.string().optional(),
  reviewAuthor: z.string().optional(),
  publishDate: z.string().optional()
});

// Validation schema for chat responses
export const BookDataSchema = z.object({
  books: z.array(BookSchema)
});

// Export types
export type ReviewMetadata = z.infer<typeof ReviewMetadataSchema>;
export type Book = z.infer<typeof BookSchema>;
export type BookData = z.infer<typeof BookDataSchema>;

// Helper to validate and extract book data from chat responses
export function extractBookData(content: string): BookData | null {
  const bookDataMatch = content.match(/<book-data>(.*?)<\/book-data>/s);
  if (!bookDataMatch) return null;
  
  try {
    const bookData = JSON.parse(bookDataMatch[1]);
    return BookDataSchema.parse(bookData);
  } catch (error) {
    console.error('Error parsing book data:', error);
    return null;
  }
}

// Helper to format review metadata for vector storage
export function formatReviewMetadata(review: ReviewMetadata): Record<string, any> {
  return {
    postId: review.postId,
    title: review.title,
    authorName: review.authorName,
    permalink: review.permalink,
    featuredImage: review.featuredImage,
    excerpt: review.excerpt,
    content: review.content,
    grade: review.grade,
    sensuality: review.sensuality,
    bookTypes: review.bookTypes?.join(', '),
    reviewTags: review.reviewTags?.join(', '),
    amazonLinks: review.amazonLinks?.join(', '),
    asin: review.asin,
    publishDate: review.publishDate,
    reviewAuthor: review.reviewAuthor
  };
}

// Helper to check if string is book data
export function isBookData(content: string): boolean {
  return content.includes('<book-data>') && content.includes('</book-data>');
}

================
File: lib/utils.ts
================
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"
 
export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

================
File: public/file.svg
================
<svg fill="none" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M14.5 13.5V5.41a1 1 0 0 0-.3-.7L9.8.29A1 1 0 0 0 9.08 0H1.5v13.5A2.5 2.5 0 0 0 4 16h8a2.5 2.5 0 0 0 2.5-2.5m-1.5 0v-7H8v-5H3v12a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1M9.5 5V2.12L12.38 5zM5.13 5h-.62v1.25h2.12V5zm-.62 3h7.12v1.25H4.5zm.62 3h-.62v1.25h7.12V11z" clip-rule="evenodd" fill="#666" fill-rule="evenodd"/></svg>

================
File: public/globe.svg
================
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><g clip-path="url(#a)"><path fill-rule="evenodd" clip-rule="evenodd" d="M10.27 14.1a6.5 6.5 0 0 0 3.67-3.45q-1.24.21-2.7.34-.31 1.83-.97 3.1M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16m.48-1.52a7 7 0 0 1-.96 0H7.5a4 4 0 0 1-.84-1.32q-.38-.89-.63-2.08a40 40 0 0 0 3.92 0q-.25 1.2-.63 2.08a4 4 0 0 1-.84 1.31zm2.94-4.76q1.66-.15 2.95-.43a7 7 0 0 0 0-2.58q-1.3-.27-2.95-.43a18 18 0 0 1 0 3.44m-1.27-3.54a17 17 0 0 1 0 3.64 39 39 0 0 1-4.3 0 17 17 0 0 1 0-3.64 39 39 0 0 1 4.3 0m1.1-1.17q1.45.13 2.69.34a6.5 6.5 0 0 0-3.67-3.44q.65 1.26.98 3.1M8.48 1.5l.01.02q.41.37.84 1.31.38.89.63 2.08a40 40 0 0 0-3.92 0q.25-1.2.63-2.08a4 4 0 0 1 .85-1.32 7 7 0 0 1 .96 0m-2.75.4a6.5 6.5 0 0 0-3.67 3.44 29 29 0 0 1 2.7-.34q.31-1.83.97-3.1M4.58 6.28q-1.66.16-2.95.43a7 7 0 0 0 0 2.58q1.3.27 2.95.43a18 18 0 0 1 0-3.44m.17 4.71q-1.45-.12-2.69-.34a6.5 6.5 0 0 0 3.67 3.44q-.65-1.27-.98-3.1" fill="#666"/></g><defs><clipPath id="a"><path fill="#fff" d="M0 0h16v16H0z"/></clipPath></defs></svg>

================
File: public/next.svg
================
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 394 80"><path fill="#000" d="M262 0h68.5v12.7h-27.2v66.6h-13.6V12.7H262V0ZM149 0v12.7H94v20.4h44.3v12.6H94v21h55v12.6H80.5V0h68.7zm34.3 0h-17.8l63.8 79.4h17.9l-32-39.7 32-39.6h-17.9l-23 28.6-23-28.6zm18.3 56.7-9-11-27.1 33.7h17.8l18.3-22.7z"/><path fill="#000" d="M81 79.3 17 0H0v79.3h13.6V17l50.2 62.3H81Zm252.6-.4c-1 0-1.8-.4-2.5-1s-1.1-1.6-1.1-2.6.3-1.8 1-2.5 1.6-1 2.6-1 1.8.3 2.5 1a3.4 3.4 0 0 1 .6 4.3 3.7 3.7 0 0 1-3 1.8zm23.2-33.5h6v23.3c0 2.1-.4 4-1.3 5.5a9.1 9.1 0 0 1-3.8 3.5c-1.6.8-3.5 1.3-5.7 1.3-2 0-3.7-.4-5.3-1s-2.8-1.8-3.7-3.2c-.9-1.3-1.4-3-1.4-5h6c.1.8.3 1.6.7 2.2s1 1.2 1.6 1.5c.7.4 1.5.5 2.4.5 1 0 1.8-.2 2.4-.6a4 4 0 0 0 1.6-1.8c.3-.8.5-1.8.5-3V45.5zm30.9 9.1a4.4 4.4 0 0 0-2-3.3 7.5 7.5 0 0 0-4.3-1.1c-1.3 0-2.4.2-3.3.5-.9.4-1.6 1-2 1.6a3.5 3.5 0 0 0-.3 4c.3.5.7.9 1.3 1.2l1.8 1 2 .5 3.2.8c1.3.3 2.5.7 3.7 1.2a13 13 0 0 1 3.2 1.8 8.1 8.1 0 0 1 3 6.5c0 2-.5 3.7-1.5 5.1a10 10 0 0 1-4.4 3.5c-1.8.8-4.1 1.2-6.8 1.2-2.6 0-4.9-.4-6.8-1.2-2-.8-3.4-2-4.5-3.5a10 10 0 0 1-1.7-5.6h6a5 5 0 0 0 3.5 4.6c1 .4 2.2.6 3.4.6 1.3 0 2.5-.2 3.5-.6 1-.4 1.8-1 2.4-1.7a4 4 0 0 0 .8-2.4c0-.9-.2-1.6-.7-2.2a11 11 0 0 0-2.1-1.4l-3.2-1-3.8-1c-2.8-.7-5-1.7-6.6-3.2a7.2 7.2 0 0 1-2.4-5.7 8 8 0 0 1 1.7-5 10 10 0 0 1 4.3-3.5c2-.8 4-1.2 6.4-1.2 2.3 0 4.4.4 6.2 1.2 1.8.8 3.2 2 4.3 3.4 1 1.4 1.5 3 1.5 5h-5.8z"/></svg>

================
File: public/vercel.svg
================
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1155 1000"><path d="m577.3 0 577.4 1000H0z" fill="#fff"/></svg>

================
File: public/window.svg
================
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 2.5h13v10a1 1 0 0 1-1 1h-11a1 1 0 0 1-1-1zM0 1h16v11.5a2.5 2.5 0 0 1-2.5 2.5h-11A2.5 2.5 0 0 1 0 12.5zm3.75 4.5a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5M7 4.75a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0m1.75.75a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5" fill="#666"/></svg>

================
File: scripts/inspect-db.ts
================
import { Pinecone } from '@pinecone-database/pinecone';
import dotenv from 'dotenv';

dotenv.config({ path: '.env.local' });

async function inspectPineconeDB() {
  try {
    // Initialize Pinecone
    const pinecone = new Pinecone();
    const indexName = process.env.PINECONE_INDEX_NAME!;
    
    if (!indexName) {
      throw new Error('PINECONE_INDEX_NAME not found in environment variables');
    }

    console.log('\n🔍 Connecting to Pinecone index:', indexName);
    const index = pinecone.Index(indexName);

    // Get index statistics
    console.log('\n📊 Fetching index statistics...');
    const stats = await index.describeIndexStats();
    
    console.log('\nIndex Statistics:');
    console.log('-----------------');
    console.log(`Total Record Count: ${stats.totalRecordCount}`);
    console.log(`Dimension: ${stats.dimension}`);
    console.log('\nNamespace Distribution:');
    if (stats.namespaces) {
      for (const [namespace, stat] of Object.entries(stats.namespaces)) {
        console.log(`- ${namespace || 'default'}: ${stat.recordCount} records`);
      }
    }

    // Create a zero vector for querying (using the index dimension)
    const dimension = stats.dimension || 1536; // Use index dimension or default to 1536
    const queryVector = new Array(dimension).fill(0);

    // Query all documents
    console.log('\n📚 Fetching documents...');
    const queryResponse = await index.query({
      vector: queryVector,
      topK: 100,
      includeMetadata: true,
      includeValues: false,
    });

    const matches = queryResponse.matches || [];
    console.log(`\nFound ${matches.length} documents`);

    // Analyze metadata fields
    const metadataFields = new Set<string>();
    matches.forEach(match => {
      if (match.metadata) {
        Object.keys(match.metadata).forEach(key => metadataFields.add(key));
      }
    });

    console.log('\n📋 Available Metadata Fields:');
    console.log('-------------------------');
    console.log(Array.from(metadataFields).sort().join('\n'));

    // Display document details
    console.log('\n📖 Document Details:');
    console.log('----------------');
    
    matches.forEach((match, idx) => {
      console.log(`\nDocument ${idx + 1}:`);
      console.log('-------------');
      console.log('ID:', match.id);
      console.log('Score:', match.score);
      
      if (match.metadata) {
        console.log('\nMetadata:');
        // Format metadata for better readability
        const formattedMetadata: Record<string, unknown> = { ...match.metadata };

        // Truncate long text fields for readability
        ['content', 'excerpt'].forEach(field => {
          if (typeof match.metadata?.[field] === 'string') {
            formattedMetadata[field] = (match.metadata[field] as string).substring(0, 200) + '...';
          }
        });

        console.dir(formattedMetadata, { depth: null, colors: true });
      }
    });

    // Print summary statistics
    console.log('\n📈 Summary:');
    console.log('---------');
    console.log(`Total documents: ${matches.length}`);
    console.log(`Metadata fields: ${metadataFields.size}`);
    
    // Check for potential issues
    const documentsWithoutTitle = matches.filter(m => !m.metadata?.title).length;
    const documentsWithoutContent = matches.filter(m => !m.metadata?.content).length;
    
    if (documentsWithoutTitle > 0 || documentsWithoutContent > 0) {
      console.log('\n⚠️  Potential Issues:');
      console.log('------------------');
      if (documentsWithoutTitle > 0) {
        console.log(`- ${documentsWithoutTitle} documents missing title`);
      }
      if (documentsWithoutContent > 0) {
        console.log(`- ${documentsWithoutContent} documents missing content`);
      }
    }

  } catch (error) {
    console.error('\n❌ Error inspecting Pinecone DB:', error);
    throw error;
  }
}

// Run the inspection
console.log('🚀 Starting Pinecone DB inspection...');

inspectPineconeDB()
  .then(() => {
    console.log('\n✅ Inspection complete!');
    process.exit(0);
  })
  .catch((error) => {
    console.error('\n❌ Fatal error:', error);
    process.exit(1);
  });

================
File: types/chat.ts
================
import { Message } from 'ai'

export interface ReviewMetadata {
  bookTitle: string;
  authorName: string;
  grade: string;
  sensuality: string;
  bookTypes?: string[];
  reviewTags?: string[];
  text: string;
}

export interface PineconeMatch {
  id: string;
  score: number;
  metadata?: ReviewMetadata;
}

export type ChatMessage = Message;

export interface ChatProps {
  initialMessages?: Message[];
  id?: string;
}

export interface BookData {
  title: string;
  author: string;
  grade?: string;
  sensuality?: string;
  bookTypes?: string[];
  asin?: string;
  reviewUrl?: string;
  postId?: string;
  featuredImage?: string;
}

================
File: .eslintrc.json
================
{
  "extends": ["next/core-web-vitals"],
  "parserOptions": {
    "project": "./tsconfig.json"
  }
}

================
File: .gitignore
================
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# env files (can opt-in for committing if needed)
.env*

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts

================
File: components.json
================
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "tailwind.config.ts",
    "css": "app/globals.css",
    "baseColor": "neutral",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "iconLibrary": "lucide"
}

================
File: next.config.js
================
/** @type {import('next').NextConfig} */
const nextConfig = {
  /* config options here */
}

module.exports = nextConfig

================
File: package.json
================
{
  "name": "minerva",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "see-db": "tsx scripts/inspect-db.ts"
  },
  "dependencies": {
    "@ai-sdk/openai": "^1.0.5",
    "@langchain/community": "^0.3.16",
    "@langchain/openai": "^0.3.14",
    "@langchain/pinecone": "^0.1.3",
    "@pinecone-database/pinecone": "^4.0.0",
    "@radix-ui/react-avatar": "^1.1.1",
    "@radix-ui/react-scroll-area": "^1.2.1",
    "@radix-ui/react-slot": "^1.0.2",
    "ai": "^4.0.7",
    "class-variance-authority": "^0.7.0",
    "clsx": "^2.1.1",
    "framer-motion": "^11.12.0",
    "langchain": "^0.3.6",
    "lucide-react": "^0.309.0",
    "minimatch": "^3.1.2",
    "next": "14.1.0",
    "openai": "^4.73.1",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-intersection-observer": "^9.13.1",
    "repomix": "^0.2.5",
    "sonner": "^1.7.0",
    "tailwind-merge": "^2.5.5",
    "zod": "^3.23.8"
  },
  "devDependencies": {
    "@tailwindcss/typography": "^0.5.15",
    "@types/node": "^20",
    "@types/react": "^18",
    "@types/react-dom": "^18",
    "autoprefixer": "^10.4.20",
    "eslint": "^8",
    "eslint-config-next": "14.1.0",
    "postcss": "^8.4.49",
    "tailwindcss": "^3.4.15",
    "tailwindcss-animate": "^1.0.7",
    "typescript": "^5"
  }
}

================
File: postcss.config.js
================
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}

================
File: postcss.config.mjs
================
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}

================
File: README.md
================
# Project Minerva: AI-Powered Romance Book Review Chatbot

## Project Overview
Project Minerva is an intelligent chatbot system designed specifically for All About Romance, a WordPress-based romance book review platform. The chatbot aims to enhance user engagement by providing natural, context-aware conversations about romance books, reviews, and recommendations.

## Core Objectives
1. Create an intuitive, conversational interface for exploring romance book reviews
2. Integrate seamlessly with existing WordPress infrastructure
3. Provide accurate, context-aware responses to user queries
4. Scale efficiently to handle growing user interactions
5. Maintain conversation history and context for meaningful interactions

## Key Features

### 1. Natural Language Understanding
- Process and understand user queries about books, authors, and reviews
- Handle complex questions about plot elements, character dynamics, and themes
- Support follow-up questions and maintain conversation context
- Example queries:
  - "What are the best enemies-to-lovers romances from 2024?"
  - "Find me books similar to 'The Love Hypothesis'"
  - "What did reviewers say about the character development in this book?"

### 2. Review Integration
- Access and analyze existing book reviews from the WordPress database
- Incorporate user comments and ratings into responses
- Provide balanced perspectives from multiple reviews
- Generate comprehensive summaries of review content

### 3. Recommendation Engine
- Suggest similar books based on user preferences
- Filter recommendations by subgenre, tropes, heat level, etc.
- Consider review ratings and user feedback in suggestions
- Provide personalized reading lists

### 4. WordPress Integration
- Seamless embedding in WordPress pages and posts
- Real-time access to review database
- Consistent styling with website theme
- Mobile-responsive design

## Technical Architecture

### Frontend Stack
1. **Next.js 14**
   - App Router for routing
   - Server Components for optimal performance
   - API Routes for backend functionality
   - Tailwind CSS for styling
   - TypeScript for type safety

2. **UI Components**
   - Shadcn/ui for core components
   - Custom chat interface
   - Loading states and animations
   - Error handling and feedback

### Backend Services

1. **LangChain Framework**
   - RAG (Retrieval-Augmented Generation) implementation
   - Conversation chain management
   - Context window optimization
   - Memory management for chat history

2. **Vector Database (Pinecone)**
   - Store and retrieve review embeddings
   - Semantic search capabilities
   - Real-time updates for new content
   - Efficient similarity search

3. **WordPress Integration**
   - WPGraphQL plugin for data access
   - Custom post type for reviews
   - Real-time content synchronization
   - User authentication integration

### Data Flow
1. Content Processing
   ```
   WordPress Reviews → Vector Embeddings → Pinecone DB
   ```

2. Query Processing
   ```
   User Query → LangChain → Vector Search → LLM → Response
   ```

3. Context Management
   ```
   Chat History → Memory System → Context Window → Response Generation
   ```

## Development Phases

### Phase 1: Foundation
- Set up Next.js project structure
- Implement basic chat interface
- Configure WordPress GraphQL integration
- Set up development and staging environments

### Phase 2: Core Features
- Implement RAG system with LangChain
- Set up vector database and embeddings
- Create basic conversation flows
- Develop review parsing system

### Phase 3: Enhancement
- Add advanced query handling
- Implement recommendation system
- Optimize response generation
- Add error handling and fallbacks

### Phase 4: WordPress Plugin
- Develop WordPress plugin
- Create admin interface
- Implement configuration options
- Add analytics and monitoring

## Deployment Strategy
1. **Frontend**
   - Vercel for Next.js application
   - Automated deployments from GitHub
   - Environment variable management
   - Performance monitoring

2. **Backend Services**
   - Serverless functions for API endpoints
   - Vector database hosting
   - WordPress plugin distribution
   - Backup and recovery systems

## Monitoring and Maintenance
- Track user interactions and feedback
- Monitor system performance
- Regular updates to vector database
- Continuous improvement of responses

## Security Considerations
- User data protection
- API key management
- Rate limiting
- Error logging and monitoring
- GDPR compliance

## Future Enhancements
1. User preference learning
2. Multi-language support
3. Voice interface
4. Advanced analytics dashboard
5. Integration with e-commerce systems

## Project Constraints
- API rate limits
- Content freshness
- Response time requirements
- Resource optimization
- Cost management

## Success Metrics
1. User engagement rates
2. Response accuracy
3. Query resolution time
4. User satisfaction scores
5. System uptime and reliability

This document serves as a living reference for Project Minerva's development and can be updated as the project evolves.

We have the latest 1000 reviews indexed

================
File: tailwind.config.ts
================
import type { Config } from "tailwindcss"

const config = {
  content: [
    "./app/**/*.{js,ts,jsx,tsx,mdx}",
    "./pages/**/*.{js,ts,jsx,tsx,mdx}",
    "./components/**/*.{js,ts,jsx,tsx,mdx}",
  ],
  theme: {
    extend: {
      fontFamily: {
        sans: ['var(--font-inter)', 'system-ui', 'sans-serif'],
        serif: ['var(--font-dm-serif)', 'serif'],
      },
      colors: {
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))",
        },
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))",
        },
      },
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
      },
    },
  },
  plugins: [
    require("tailwindcss-animate"),
    require("@tailwindcss/typography")
  ],
} satisfies Config

export default config

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "target": "es2018",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
