This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-11-28T20:54:31.293Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
app/
  actions.ts
  globals.css
  layout.tsx
  page.tsx
components/
  chat/
    BookReviewCard.tsx
    ChatInput.tsx
    ChatInterface.tsx
    ChatMessage.tsx
  ui/
    avatar.tsx
    badge.tsx
    button.tsx
    card.tsx
    input.tsx
    scroll-area.tsx
    textarea.tsx
lib/
  services/
    chat.ts
    pinecone.ts
  validators/
    book-data.ts
  utils.ts
public/
  file.svg
  globe.svg
  next.svg
  vercel.svg
  window.svg
scripts/
  inspect-db.ts
types/
  chat.ts
.eslintrc.json
.gitignore
components.json
next.config.js
package.json
postcss.config.js
postcss.config.mjs
README.md
tailwind.config.ts
tsconfig.json

================================================================
Repository Files
================================================================

================
File: app/actions.ts
================
'use server';

import { createStreamableValue } from 'ai/rsc';
import { type Message } from 'ai';
import { chatService } from '@/lib/services/chat';

// Re-export Message type for use in other components
export type { Message };

// Timeout constant (30 seconds)
const STREAM_TIMEOUT = 30000;

/**
 * Server action to continue conversation with AI assistant
 * @param history Array of conversation messages
 * @returns Object containing message history and streamed response
 */
export async function continueConversation(history: Message[]) {
  const stream = createStreamableValue();
  
  // Create timeout promise
  const timeoutPromise = new Promise((_, reject) => {
    setTimeout(() => {
      reject(new Error('Stream timeout'));
    }, STREAM_TIMEOUT);
  });

  (async () => {
    try {
      // Log incoming message
      const latestMessage = history[history.length - 1].content;
      console.log('Processing message:', latestMessage);

      // Get streaming response from chat service
      const textStream = await chatService.processMessage(history);
      let fullResponse = '';
      let lastUpdate = Date.now();

      // Stream response with race against timeout
      await Promise.race([
        (async () => {
          for await (const chunk of textStream) {
            fullResponse += chunk;
            
            // Rate limit updates to every 100ms
            const now = Date.now();
            if (now - lastUpdate >= 100) {
              stream.update(chunk);
              lastUpdate = now;
            }
          }
        })(),
        timeoutPromise
      ]);

      // Final update
      if (fullResponse) {
        stream.update(fullResponse);
        console.log('Completed response:', fullResponse.slice(0, 200) + '...');
      }
      
      stream.done();

    } catch (error) {
      console.error('Error in chat stream:', error);
      
      let errorMessage: string;
      
      if (error instanceof Error) {
        if (error.message === 'Stream timeout') {
          errorMessage = "I apologize, but the response took too long. Please try a shorter query or try again.";
        } else if (error.message.includes('database')) {
          errorMessage = "I apologize, but I encountered an error accessing the review database. This has been logged and will be investigated.";
        } else {
          errorMessage = "I apologize, but I encountered an error processing your request. Please try again in a moment.";
        }
      } else {
        errorMessage = "An unexpected error occurred. Please try again.";
      }

      // Send error message and complete stream
      stream.update(errorMessage);
      stream.done();
    }
  })();

  // Return message history and stream
  return {
    messages: history,
    newMessage: stream.value,
  };
}

================
File: app/globals.css
================
@tailwind base;
@tailwind components;
@tailwind utilities;
 
@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 240 10% 3.9%;
    --card: 0 0% 100%;
    --card-foreground: 240 10% 3.9%;
    --popover: 0 0% 100%;
    --popover-foreground: 240 10% 3.9%;
    --primary: 236 35% 63%;
    --primary-foreground: 0 0% 98%;
    --secondary: 240 4.8% 95.9%;
    --secondary-foreground: 240 5.9% 10%;
    --muted: 240 4.8% 95.9%;
    --muted-foreground: 240 3.8% 46.1%;
    --accent: 240 4.8% 95.9%;
    --accent-foreground: 240 5.9% 10%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 0 0% 98%;
    --border: 240 5.9% 90%;
    --input: 240 5.9% 90%;
    --ring: 236 35% 63%;
    --radius: 0.5rem;
  }
 
  .dark {
    --background: 240 10% 3.9%;
    --foreground: 0 0% 98%;
    --card: 240 10% 3.9%;
    --card-foreground: 0 0% 98%;
    --popover: 240 10% 3.9%;
    --popover-foreground: 0 0% 98%;
    --primary: 236 35% 63%;
    --primary-foreground: 240 5.9% 10%;
    --secondary: 240 3.7% 15.9%;
    --secondary-foreground: 0 0% 98%;
    --muted: 240 3.7% 15.9%;
    --muted-foreground: 240 5% 64.9%;
    --accent: 240 3.7% 15.9%;
    --accent-foreground: 0 0% 98%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 0 0% 98%;
    --border: 240 3.7% 15.9%;
    --input: 240 3.7% 15.9%;
    --ring: 236 35% 63%;
  }
}

/* Base Styles */
@layer base {
  * {
    @apply border-border;
  }
  
  html {
    @apply antialiased;
    scroll-behavior: smooth;
  }

  body {
    @apply bg-background text-foreground antialiased min-h-screen overflow-hidden;
    font-family: var(--font-inter), system-ui, sans-serif;
  }

  h1, h2, h3, h4, h5, h6, .font-serif {
    font-family: var(--font-dm-serif), serif;
    letter-spacing: -0.02em;
  }

  /* Selection styles */
  ::selection {
    @apply bg-[#7f85c2]/30 text-white;
  }
}

/* Custom Scrollbar */
@layer utilities {
  .custom-scrollbar {
    scrollbar-width: thin;
    scrollbar-color: rgba(127, 133, 194, 0.3) transparent;
  }

  .custom-scrollbar::-webkit-scrollbar {
    @apply w-1.5;
  }

  .custom-scrollbar::-webkit-scrollbar-track {
    @apply bg-transparent;
  }

  .custom-scrollbar::-webkit-scrollbar-thumb {
    @apply bg-white/20 rounded-full transition-colors hover:bg-white/30;
  }
}

/* Animations */
@keyframes fade-in {
  from { 
    opacity: 0;
    transform: translateY(10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

@keyframes fade-out {
  from {
    opacity: 1;
    transform: translateY(0);
  }
  to {
    opacity: 0;
    transform: translateY(-10px);
  }
}

@keyframes slide-in {
  from {
    transform: translateY(100%);
    opacity: 0;
  }
  to {
    transform: translateY(0);
    opacity: 1;
  }
}

@keyframes pulse-subtle {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.7;
  }
}

@keyframes shimmer {
  0% {
    background-position: -1000px 0;
  }
  100% {
    background-position: 1000px 0;
  }
}

/* Animation Utility Classes */
.animate-fade-in {
  animation: fade-in 0.3s ease-out forwards;
}

.animate-fade-out {
  animation: fade-out 0.3s ease-out forwards;
}

.animate-slide-in {
  animation: slide-in 0.4s cubic-bezier(0.4, 0, 0.2, 1) forwards;
}

.animate-pulse-subtle {
  animation: pulse-subtle 2s ease-in-out infinite;
}

/* Loading Skeleton */
.loading-skeleton {
  @apply relative overflow-hidden bg-white/10 rounded;
}

.loading-skeleton::after {
  @apply absolute inset-0;
  content: '';
  background-image: linear-gradient(
    90deg,
    rgba(255, 255, 255, 0) 0,
    rgba(255, 255, 255, 0.05) 20%,
    rgba(255, 255, 255, 0.1) 60%,
    rgba(255, 255, 255, 0)
  );
  animation: shimmer 2s infinite linear;
}

/* Prose Styles */
.prose {
  @apply max-w-none;
}

.prose h1, .prose h2, .prose h3 {
  @apply text-white font-serif;
}

.prose p {
  @apply text-white/90 leading-relaxed;
}

.prose ul {
  @apply space-y-1 list-disc list-inside;
}

.prose li {
  @apply text-white/90;
}

.prose blockquote {
  @apply border-l-2 border-[#7f85c2] pl-4 py-2 my-4 text-white/90 italic;
}

.prose a {
  @apply text-[#7f85c2] hover:text-[#6b70a3] transition-colors no-underline;
}

.prose strong {
  @apply text-white font-semibold;
}

.prose em {
  @apply text-white/90 italic;
}

/* Background Styles */
body {
  @apply min-h-screen overflow-hidden;
  background-color: #1a1a2e;
}

body::before {
  content: '';
  @apply fixed inset-0;
  background: radial-gradient(
    circle at center,
    rgba(127, 133, 194, 0.15) 0%,
    rgba(26, 26, 46, 0.9) 50%,
    rgba(26, 26, 46, 1) 100%
  );
  z-index: -1;
}

/* Layout Styles */
.layout-container {
  @apply flex flex-col min-h-screen;
}

.main-content {
  @apply flex-grow flex items-center justify-center p-4;
}

.chat-container {
  @apply w-full max-w-4xl mx-auto;
}

/* Transition Utilities */
.custom-transition {
  @apply transition-all duration-200 ease-in-out;
}

.custom-transition-transform {
  @apply transition-transform duration-200 ease-in-out;
}

.custom-transition-opacity {
  @apply transition-opacity duration-200 ease-in-out;
}

/* Focus Styles */
.focus-ring {
  @apply focus:outline-none focus-visible:ring-2 focus-visible:ring-[#7f85c2] focus-visible:ring-offset-2 focus-visible:ring-offset-[#1a1a2e];
}

/* Hover Effects */
.hover-lift {
  @apply transition-transform hover:-translate-y-0.5;
}

.hover-glow {
  @apply transition-shadow hover:shadow-lg hover:shadow-[#7f85c2]/20;
}

/* Mobile Optimizations */
@media (max-width: 640px) {
  .prose {
    @apply text-sm;
  }

  .chat-container {
    @apply p-2;
  }

  .custom-scrollbar::-webkit-scrollbar {
    @apply w-1;
  }
}

/* Print Styles */
@media print {
  .chat-container {
    @apply max-w-none;
  }

  .custom-scrollbar::-webkit-scrollbar {
    @apply hidden;
  }
}

================
File: app/layout.tsx
================
import "./globals.css"
import type { Metadata } from "next"
import { DM_Serif_Text, Inter } from 'next/font/google'

const dmSerifText = DM_Serif_Text({
  subsets: ['latin'],
  weight: ['400'],
  variable: '--font-dm-serif',
})

const inter = Inter({
  subsets: ['latin'],
  variable: '--font-inter',
})

export const metadata: Metadata = {
  title: "Minerva - AAR Assistant",
  description: "AI-powered romance book review chatbot for All About Romance - Find your next great romance read!",
  keywords: "romance books, book reviews, AI chatbot, book recommendations, All About Romance",
  authors: [{ name: "All About Romance" }],
  openGraph: {
    title: "Minerva - AAR Assistant",
    description: "Find your next great romance read with AI-powered book recommendations and reviews.",
    url: "https://allaboutromance.com",
    siteName: "All About Romance",
    type: "website",
  },
  twitter: {
    card: "summary_large_image",
    title: "Minerva - AAR Assistant",
    description: "AI-powered romance book recommendations and reviews",
  },
}

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html 
      lang="en" 
      className={`${dmSerifText.variable} ${inter.variable}`}
      suppressHydrationWarning
    >
      <body className="min-h-screen overflow-hidden bg-[#1a1a2e]">
        <div className="fixed inset-0 bg-[radial-gradient(circle_at_center,rgba(127,133,194,0.15)_0%,rgba(26,26,46,0.9)_50%,rgba(26,26,46,1)_100%)]" />
        <div className="relative h-screen">
          {children}
        </div>
      </body>
    </html>
  )
}

================
File: app/page.tsx
================
'use client';

import { useState, useEffect, useCallback, useRef } from 'react';
import { type Message } from 'ai';
import { readStreamableValue } from 'ai/rsc';
import { Toaster, toast } from 'sonner';
import { continueConversation } from '@/app/actions';
import { ChatInterface } from '@/components/chat/ChatInterface';
import { usePathname, useRouter, useSearchParams } from 'next/navigation';

// Import the server action properly


const MAX_RETRIES = 3;
const RETRY_DELAY = 1000; // 1 second
const MESSAGE_TIMEOUT = 30000; // 30 seconds
const MAX_CONVERSATION_LENGTH = 20;

interface ChatError extends Error {
  message: string;
}

export default function Home() {
  const [mounted, setMounted] = useState(false);
  const [conversation, setConversation] = useState<Message[]>([]);
  const [input, setInput] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const abortController = useRef<AbortController | null>(null);
  const timeoutRef = useRef<NodeJS.Timeout | null>(null);
  const retryCountRef = useRef(0);

  const router = useRouter();
  const pathname = usePathname();
  const searchParams = useSearchParams();

  // Initialize component
  useEffect(() => {
    setMounted(true);
    return () => {
      // Cleanup timeouts and abort controller on unmount
      if (timeoutRef.current) clearTimeout(timeoutRef.current);
      if (abortController.current) abortController.current.abort();
    };
  }, []);

  // Share conversation handler
  const handleShareConversation = useCallback(() => {
    const shareableMessages = conversation.map(msg => ({
      role: msg.role,
      content: msg.content
    }));
    
    const shareUrl = new URL(window.location.href);
    shareUrl.searchParams.set('messages', JSON.stringify(shareableMessages));
    
    navigator.clipboard.writeText(shareUrl.toString())
      .then(() => toast.success('Conversation link copied to clipboard!'))
      .catch(() => toast.error('Failed to copy conversation link'));
  }, [conversation]);

  // Load shared conversation
  useEffect(() => {
    if (!mounted) return;

    const messagesParam = searchParams.get('messages');
    if (messagesParam) {
      try {
        const sharedMessages = JSON.parse(messagesParam) as Message[];
        setConversation(sharedMessages.map((msg, index) => ({
          ...msg,
          id: `shared-${index}`
        })));
      } catch (error) {
        console.error('Error loading shared conversation:', error);
        toast.error('Failed to load shared conversation');
      }
    }
  }, [mounted, searchParams]);

  // Handle message sending with retries and timeout
  const handleSend = async (content: string, retryCount = 0) => {
    try {
      setIsLoading(true);
      
      // Cancel any existing request
      if (abortController.current) {
        abortController.current.abort();
      }
      
      // Create new abort controller
      abortController.current = new AbortController();

      // Set timeout
      timeoutRef.current = setTimeout(() => {
        if (abortController.current) {
          abortController.current.abort();
          throw new Error('Response timeout');
        }
      }, MESSAGE_TIMEOUT);

      // Check conversation length
      if (conversation.length >= MAX_CONVERSATION_LENGTH) {
        toast.warning('Conversation limit reached. Starting new conversation.');
        setConversation([]);
      }

      // Create new message
      const newUserMessage: Message = { 
        role: 'user', 
        content, 
        id: Date.now().toString() 
      };

      const newConversation = [...conversation, newUserMessage];
      setConversation(newConversation);
      setInput('');

      // Get streaming response
      const { messages, newMessage } = await continueConversation(newConversation);
      
      let textContent = '';
      let lastUpdate = Date.now();

      for await (const delta of readStreamableValue(newMessage)) {
        // Update content and check timeout
        textContent = `${textContent}${delta}`;
        const currentTime = Date.now();
        
        if (currentTime - lastUpdate > 100) { // Update UI every 100ms
          setConversation([
            ...messages,
            { 
              role: 'assistant', 
              content: textContent, 
              id: 'response-' + Date.now() 
            }
          ]);
          lastUpdate = currentTime;
        }
      }

      // Final update
      setConversation([
        ...messages,
        { 
          role: 'assistant', 
          content: textContent, 
          id: 'response-' + Date.now() 
        }
      ]);

      // Reset retry count on success
      retryCountRef.current = 0;

    } catch (error) {
      console.error('Error in chat:', error);
      const chatError = error as ChatError;

      // Handle retries
      if (retryCount < MAX_RETRIES && chatError.message !== 'Aborted') {
        retryCountRef.current = retryCount + 1;
        toast.error(`Connection error. Retrying... (${retryCount + 1}/${MAX_RETRIES})`);
        
        setTimeout(() => {
          handleSend(content, retryCount + 1);
        }, RETRY_DELAY * Math.pow(2, retryCount)); // Exponential backoff
        
        return;
      }

      // Show appropriate error message
      if (chatError.message === 'Response timeout') {
        toast.error('Response took too long. Please try again.');
      } else if (chatError.message === 'Aborted') {
        toast.info('Request cancelled.');
      } else {
        toast.error('Failed to get response. Please try again.');
      }

      // Remove failed message from conversation
      setConversation(prev => prev.slice(0, -1));

    } finally {
      setIsLoading(false);
      if (timeoutRef.current) clearTimeout(timeoutRef.current);
      abortController.current = null;
    }
  };

  if (!mounted) return null;

  return (
    <div className="flex min-h-screen items-center justify-center p-4">
      <Toaster 
        position="top-center" 
        richColors 
        closeButton
        duration={3000}
      />
      
      <ChatInterface 
        messages={conversation}
        input={input}
        handleInputChange={(e) => setInput(e.target.value)}
        handleSubmit={(e) => {
          e.preventDefault();
          if (!input.trim() || isLoading) return;
          handleSend(input.trim());
        }}
        isLoading={isLoading}
      />
    </div>
  );
}

================
File: components/chat/BookReviewCard.tsx
================
import { Badge } from "@/components/ui/badge"
import { Button } from "@/components/ui/button"
import { Card, CardContent } from "@/components/ui/card"
import { ExternalLink, Star, BookOpen, ThermometerSun, Tag } from 'lucide-react'
import { motion } from 'framer-motion'

interface BookReviewCardProps {
  title: string
  author: string
  grade?: string 
  sensuality?: string
  bookTypes?: string[]
  asin?: string
  reviewUrl?: string
  postId?: string
  featuredImage?: string
  reviewTags?: string[]
}

const gradeColors = {
  'A+': 'bg-emerald-500',
  'A': 'bg-emerald-400',
  'A-': 'bg-emerald-300',
  'B+': 'bg-blue-500',
  'B': 'bg-blue-400',
  'B-': 'bg-blue-300',
  'C+': 'bg-yellow-500',
  'C': 'bg-yellow-400',
  'C-': 'bg-yellow-300',
  'D+': 'bg-orange-500',
  'D': 'bg-orange-400',
  'D-': 'bg-orange-300',
  'F': 'bg-red-500'
} as const

const sensualityColors = {
  'Burning': 'bg-red-500/20 text-red-200',
  'Hot': 'bg-orange-500/20 text-orange-200',
  'Warm': 'bg-yellow-500/20 text-yellow-200',
  'Subtle': 'bg-blue-500/20 text-blue-200',
  'Kisses': 'bg-pink-500/20 text-pink-200',
  'None': 'bg-gray-500/20 text-gray-200',
} as const

export default function BookReviewCard({
  title,
  author,
  grade,
  sensuality,
  bookTypes = [],
  asin,
  reviewUrl,
  postId,
  featuredImage,
  reviewTags = []
}: BookReviewCardProps) {
  const gradeKey = grade as keyof typeof gradeColors
  const sensualityKey = sensuality as keyof typeof sensualityColors

  return (
    <motion.div
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      exit={{ opacity: 0, y: -20 }}
      transition={{ 
        duration: 0.5,
        ease: [0.4, 0, 0.2, 1]
      }}
      className="relative"
    >
      <Card className="overflow-hidden bg-white/10 backdrop-blur border-white/20 transition-shadow hover:shadow-lg">
        <CardContent className="p-4">
          <div className="flex gap-4">
            <motion.div 
              initial={{ opacity: 0, scale: 0.9 }}
              animate={{ opacity: 1, scale: 1 }}
              transition={{ delay: 0.2 }}
              className="flex-shrink-0"
            >
              {featuredImage ? (
                <div className="relative w-24 h-36 overflow-hidden rounded-md">
                  <img 
                    src={featuredImage} 
                    alt={`Cover of ${title}`} 
                    className="object-cover w-full h-full transition-transform duration-300 hover:scale-110"
                  />
                </div>
              ) : (
                <div className="w-24 h-36 bg-white/5 rounded-md flex items-center justify-center">
                  <BookOpen className="w-8 h-8 text-white/50" />
                </div>
              )}
            </motion.div>
            
            <div className="flex-1 min-w-0 space-y-2">
              <motion.div
                initial={{ opacity: 0, x: -20 }}
                animate={{ opacity: 1, x: 0 }}
                transition={{ delay: 0.3 }}
              >
                <h3 className="font-serif text-xl leading-tight text-white line-clamp-2">{title}</h3>
                <p className="text-white/80 text-sm mt-1">by {author}</p>
              </motion.div>

              <motion.div 
                initial={{ opacity: 0, y: 10 }}
                animate={{ opacity: 1, y: 0 }}
                transition={{ delay: 0.4 }}
                className="flex flex-wrap gap-2"
              >
                {grade && (
                  <Badge 
                    className={`${gradeColors[gradeKey] || 'bg-[#7f85c2]/50'} text-white transition-colors`}
                  >
                    <Star className="w-3 h-3 mr-1 fill-current" />
                    {grade}
                  </Badge>
                )}
                
                {sensuality && (
                  <Badge 
                    variant="secondary" 
                    className={`${sensualityColors[sensualityKey] || 'bg-white/10 text-white'} transition-colors`}
                  >
                    <ThermometerSun className="w-3 h-3 mr-1" />
                    {sensuality}
                  </Badge>
                )}
              </motion.div>

              {(bookTypes.length > 0 || reviewTags.length > 0) && (
                <motion.div 
                  initial={{ opacity: 0, y: 10 }}
                  animate={{ opacity: 1, y: 0 }}
                  transition={{ delay: 0.5 }}
                  className="flex flex-wrap gap-2"
                >
                  {bookTypes.map((type) => (
                    <Badge 
                      key={type} 
                      variant="outline" 
                      className="border-white/20 text-sm text-white bg-white/5"
                    >
                      <Tag className="w-3 h-3 mr-1" />
                      {type}
                    </Badge>
                  ))}
                  {reviewTags.map((tag) => (
                    <Badge 
                      key={tag} 
                      variant="outline" 
                      className="border-white/20 text-sm text-white/80 bg-white/5"
                    >
                      #{tag}
                    </Badge>
                  ))}
                </motion.div>
              )}
              
              <motion.div 
                initial={{ opacity: 0, y: 10 }}
                animate={{ opacity: 1, y: 0 }}
                transition={{ delay: 0.6 }}
                className="flex flex-wrap gap-2 pt-2"
              >
                {asin && (
                  <Button 
                    variant="default"
                    size="sm"
                    className="gap-2 bg-[#7f85c2] text-white hover:bg-[#5a5f8f] transition-colors"
                    asChild
                  >
                    <a
                      href={`https://www.amazon.com/gp/product/${asin}/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=${asin}&linkCode=as2&tag=allaboutromance`}
                      target="_blank"
                      rel="noopener noreferrer"
                    >
                      Buy on Amazon
                      <ExternalLink className="w-3 h-3" />
                    </a>
                  </Button>
                )}
                
                {reviewUrl && (
                  <Button 
                    variant="secondary"
                    size="sm"
                    className="gap-2 bg-white/10 text-white hover:bg-white/20 transition-colors"
                    asChild
                  >
                    <a
                      href={reviewUrl}
                      target="_blank"
                      rel="noopener noreferrer"
                    >
                      Read Review
                      <ExternalLink className="w-3 h-3" />
                    </a>
                  </Button>
                )}
                
                {postId && !reviewUrl && (
                  <Button 
                    variant="secondary"
                    size="sm"
                    className="gap-2 bg-white/10 text-white hover:bg-white/20 transition-colors"
                    asChild
                  >
                    <a
                      href={`https://web.archive.org/web/*/https://allaboutromance.com/?p=${postId}`}
                      target="_blank"
                      rel="noopener noreferrer"
                    >
                      View Archived Review
                      <ExternalLink className="w-3 h-3" />
                    </a>
                  </Button>
                )}
              </motion.div>
            </div>
          </div>
        </CardContent>
      </Card>
    </motion.div>
  )
}

================
File: components/chat/ChatInput.tsx
================
import { Button } from "@/components/ui/button"
import { Textarea } from "@/components/ui/textarea"
import { useState, useRef, useEffect, KeyboardEvent } from "react"
import { Send } from 'lucide-react'
import { motion, AnimatePresence } from 'framer-motion'
import { cn } from "@/lib/utils"

interface ChatInputProps {
  input: string
  handleInputChange: (e: React.ChangeEvent<HTMLTextAreaElement>) => void
  handleSubmit: (e: React.FormEvent<HTMLFormElement>) => void
  isLoading: boolean
}

export function ChatInput({ 
  input, 
  handleInputChange, 
  handleSubmit, 
  isLoading 
}: ChatInputProps) {
  const textareaRef = useRef<HTMLTextAreaElement>(null)
  const formRef = useRef<HTMLFormElement>(null)
  const [isFocused, setIsFocused] = useState(false)

  // Auto-resize textarea based on content
  useEffect(() => {
    if (textareaRef.current) {
      textareaRef.current.style.height = 'auto'
      textareaRef.current.style.height = `${Math.min(textareaRef.current.scrollHeight, 200)}px`
    }
  }, [input])

  // Focus handling
  const handleFocus = () => setIsFocused(true)
  const handleBlur = () => setIsFocused(false)

  // Handle keyboard shortcuts
  const handleKeyPress = (e: KeyboardEvent<HTMLTextAreaElement>) => {
    // Submit on Enter (without shift)
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault()
      formRef.current?.requestSubmit()
      return
    }

    // New line on Shift + Enter
    if (e.key === 'Enter' && e.shiftKey) {
      return
    }
  }

  // Animation variants
  const formVariants = {
    focused: {
      scale: 1.01,
      transition: {
        type: "spring",
        stiffness: 300,
        damping: 20
      }
    },
    unfocused: {
      scale: 1
    }
  }

  const buttonVariants = {
    disabled: { 
      scale: 0.95,
      opacity: 0.5 
    },
    enabled: { 
      scale: 1,
      opacity: 1 
    },
    tap: { 
      scale: 0.95 
    },
    hover: { 
      scale: 1.05,
      backgroundColor: "rgb(107, 112, 163)" 
    }
  }

  const loadingSpinnerVariants = {
    initial: { rotate: 0 },
    animate: {
      rotate: 360,
      transition: {
        duration: 1,
        ease: "linear",
        repeat: Infinity
      }
    }
  }

  return (
    <motion.form 
      ref={formRef}
      onSubmit={handleSubmit} 
      className="relative flex items-center gap-2"
      variants={formVariants}
      animate={isFocused ? "focused" : "unfocused"}
    >
      <div className="relative flex-1">
        <Textarea
          ref={textareaRef}
          tabIndex={0}
          rows={1}
          value={input}
          onChange={handleInputChange}
          onKeyDown={handleKeyPress}
          onFocus={handleFocus}
          onBlur={handleBlur}
          placeholder="Ask about romance books, reviews, or recommendations..."
          spellCheck={true}
          className={cn(
            "min-h-[44px] w-full resize-none px-4 py-[0.6rem] rounded-lg text-white",
            "placeholder-white/50 transition-all duration-200",
            "border-none focus-visible:ring-1 focus-visible:ring-[#7f85c2]",
            "bg-white/5 hover:bg-white/10 focus:bg-white/10",
            isFocused ? "shadow-lg" : "shadow-none"
          )}
          aria-label="Type your message"
          disabled={isLoading}
        />

        {/* Character limit indicator */}
        <motion.div
          initial={{ opacity: 0 }}
          animate={{ opacity: input.length > 0 ? 1 : 0 }}
          className="absolute bottom-2 right-3 text-xs text-white/50"
        >
          {input.length > 0 && (
            <span>{input.length}/2000</span>
          )}
        </motion.div>
      </div>

      <AnimatePresence mode="wait">
        <motion.div
          variants={buttonVariants}
          initial="disabled"
          animate={isLoading || !input.trim() ? "disabled" : "enabled"}
          whileHover={isLoading || !input.trim() ? undefined : "hover"}
          whileTap={isLoading || !input.trim() ? undefined : "tap"}
        >
          <Button 
            type="submit" 
            size="icon" 
            disabled={isLoading || !input.trim()}
            className={cn(
              "shrink-0 transition-all duration-200",
              "bg-[#7f85c2] text-white hover:bg-[#6b70a3]",
              isLoading || !input.trim() ? "opacity-50 cursor-not-allowed" : "",
              isFocused ? "shadow-md" : "shadow-none"
            )}
          >
            {isLoading ? (
              <motion.div
                role="status"
                className="flex justify-center"
                aria-label="Sending message"
                variants={loadingSpinnerVariants}
                initial="initial"
                animate="animate"
              >
                <div className="h-4 w-4 rounded-full border-2 border-white border-r-transparent" />
                <span className="sr-only">Sending message...</span>
              </motion.div>
            ) : (
              <>
                <Send className="h-4 w-4" />
                <span className="sr-only">Send message</span>
              </>
            )}
          </Button>
        </motion.div>
      </AnimatePresence>
    </motion.form>
  )
}

================
File: components/chat/ChatInterface.tsx
================
import { useRef, useEffect, useState, useCallback } from 'react'
import { ChatInput } from './ChatInput'
import   ChatMessage from './ChatMessage'
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'
import { ScrollArea } from '@/components/ui/scroll-area'
import { Sparkles, ArrowDown } from 'lucide-react'
import { Message } from 'ai'
import { ChangeEvent } from 'react'
import { motion, AnimatePresence } from 'framer-motion'
import { Button } from '@/components/ui/button'

interface ChatInterfaceProps {
  messages: Message[]
  input: string
  handleInputChange: (e: ChangeEvent<HTMLInputElement> | ChangeEvent<HTMLTextAreaElement>) => void
  handleSubmit: (event: React.FormEvent<HTMLFormElement>) => void
  isLoading: boolean
  error?: Error
}

export function ChatInterface({ 
  messages = [], 
  input, 
  handleInputChange, 
  handleSubmit, 
  isLoading, 
  error 
}: ChatInterfaceProps) {
  const messagesEndRef = useRef<HTMLDivElement>(null)
  const scrollAreaRef = useRef<HTMLDivElement>(null)
  const [showScrollButton, setShowScrollButton] = useState(false)
  const [pendingMessage, setPendingMessage] = useState<string | null>(null)

  const conversationStarters = [
    "What did readers think about No Man's Land by Sally Malcolm?",
    "Tell me about A Friend in the Glass by Gregory Ashe",
    "Can you recommend books similar to Murder in Highbury?",
    "What are the latest romance book reviews?",
  ]

  // Filter out raw book data messages
  const displayMessages = messages.filter(m => 
    m.role === 'user' || (m.role === 'assistant' && (!m.content.trim().startsWith('{') || m.content.includes('</book-data>')))
  )

  // Scroll handling
  const handleScroll = useCallback(() => {
    const scrollArea = scrollAreaRef.current
    if (!scrollArea) return

    const { scrollTop, scrollHeight, clientHeight } = scrollArea
    const isNearBottom = scrollHeight - scrollTop - clientHeight < 100
    setShowScrollButton(!isNearBottom)
  }, [])

  useEffect(() => {
    const scrollArea = scrollAreaRef.current
    if (!scrollArea) return

    scrollArea.addEventListener('scroll', handleScroll)
    return () => scrollArea.removeEventListener('scroll', handleScroll)
  }, [handleScroll])

  // Auto-scroll on new messages
  useEffect(() => {
    if (messagesEndRef.current && !showScrollButton) {
      messagesEndRef.current.scrollIntoView({ 
        behavior: displayMessages.length <= 2 ? 'auto' : 'smooth',
        block: 'end'
      })
    }
  }, [displayMessages, showScrollButton])

  // Handle message submission with pending state
  const handleMessageSubmit = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault()
    if (!input.trim() || isLoading) return

    setPendingMessage(input.trim())
    await handleSubmit(event)
    setPendingMessage(null)
  }

  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ 
      behavior: 'smooth',
      block: 'end'
    })
    setShowScrollButton(false)
  }

  return (
    <Card className="flex h-[calc(100vh-2rem)] w-full max-w-4xl mx-auto overflow-hidden rounded-xl border-white/10 bg-white/5 backdrop-blur-md shadow-2xl">
      <div className="flex flex-col w-full">
        <CardHeader className="border-b border-white/10 bg-white/5 px-6">
          <CardTitle className="flex items-center gap-2 text-2xl font-serif">
            <Sparkles className="h-6 w-6 text-[#7f85c2]" />
            <motion.span 
              initial={{ opacity: 0, x: -20 }}
              animate={{ opacity: 1, x: 0 }}
              className="bg-gradient-to-r from-white to-white/80 bg-clip-text text-transparent"
            >
              Minerva - AAR Assistant
            </motion.span>
          </CardTitle>
        </CardHeader>

        <CardContent className="flex-1 overflow-hidden p-4">
          <ScrollArea 
            className="h-full pr-4 custom-scrollbar" 
            ref={scrollAreaRef}
          >
            <AnimatePresence mode="wait">
              {displayMessages.length === 0 ? (
                <motion.div
                  initial={{ opacity: 0, y: 20 }}
                  animate={{ opacity: 1, y: 0 }}
                  exit={{ opacity: 0, y: -20 }}
                  transition={{ duration: 0.5 }}
                  className="flex flex-col items-center justify-center h-full text-center space-y-4 p-4"
                >
                  <p className="text-xl font-medium font-serif text-white">
                    Welcome to All About Romance!
                  </p>
                  <p className="text-sm text-white/80 mb-4">
                    Ask me about romance books, reviews, or get personalized recommendations.
                  </p>
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-3 w-full max-w-2xl">
                    {conversationStarters.map((starter, index) => (
                      <motion.button
                        key={index}
                        initial={{ opacity: 0, y: 20 }}
                        animate={{ opacity: 1, y: 0 }}
                        whileHover={{ scale: 1.02 }}
                        whileTap={{ scale: 0.98 }}
                        transition={{ 
                          duration: 0.3, 
                          delay: index * 0.1,
                          type: "spring",
                          stiffness: 300
                        }}
                        onClick={() => {
                          handleInputChange({ target: { value: starter } } as ChangeEvent<HTMLInputElement>)
                          handleMessageSubmit({ preventDefault: () => {} } as React.FormEvent<HTMLFormElement>)
                        }}
                        className="p-4 text-left rounded-lg bg-white/5 hover:bg-white/10 transition-colors text-sm text-white/90 border border-white/10"
                      >
                        {starter}
                      </motion.button>
                    ))}
                  </div>
                </motion.div>
              ) : (
                <div className="space-y-6 py-4">
                  <AnimatePresence mode="popLayout" initial={false}>
                    {displayMessages.map((message, index) => (
                      <motion.div
                        key={message.id || index}
                        initial={{ opacity: 0, y: 20 }}
                        animate={{ opacity: 1, y: 0 }}
                        exit={{ opacity: 0, y: -20 }}
                        transition={{ 
                          duration: 0.4,
                          type: "spring",
                          damping: 20
                        }}
                      >
                        <ChatMessage
                          message={message}
                          isLoading={isLoading && index === displayMessages.length - 1}
                        />
                      </motion.div>
                    ))}

                    {/* Pending message animation */}
                    {pendingMessage && (
                      <motion.div
                        key="pending"
                        initial={{ opacity: 0, y: 20 }}
                        animate={{ opacity: 1, y: 0 }}
                        exit={{ opacity: 0, y: -20 }}
                        transition={{ duration: 0.3 }}
                      >
                        <ChatMessage
                          message={{ role: 'user', content: pendingMessage, id: 'pending' }}
                          isLoading={false}
                        />
                      </motion.div>
                    )}
                  </AnimatePresence>
                  <div ref={messagesEndRef} />
                </div>
              )}
            </AnimatePresence>
          </ScrollArea>

          {/* Scroll to bottom button */}
          <AnimatePresence>
            {showScrollButton && (
              <motion.div
                initial={{ opacity: 0, y: 20 }}
                animate={{ opacity: 1, y: 0 }}
                exit={{ opacity: 0, y: 20 }}
                transition={{ duration: 0.2 }}
                className="absolute bottom-24 right-6"
              >
                <Button
                  onClick={scrollToBottom}
                  size="sm"
                  className="bg-[#7f85c2] text-white hover:bg-[#6b70a3] transition-colors rounded-full shadow-lg px-4 py-2 flex items-center gap-2"
                >
                  <ArrowDown className="w-4 h-4" />
                  <span className="text-sm">New messages</span>
                </Button>
              </motion.div>
            )}
          </AnimatePresence>
        </CardContent>

        <div className="p-4 border-t border-white/10 bg-white/5">
          <ChatInput
            input={input}
            handleInputChange={handleInputChange}
            handleSubmit={handleMessageSubmit}
            isLoading={isLoading}
          />
        </div>
      </div>
    </Card>
  )
}

================
File: components/chat/ChatMessage.tsx
================
import { Message } from "ai"
import { cn } from "@/lib/utils"
import { Avatar } from "../ui/avatar"
import { Bot, User } from 'lucide-react'
import { useEffect, useState, memo } from "react"
import BookReviewCard from "./BookReviewCard"
import { Book } from "@/lib/validators/book-data"
import { motion, AnimatePresence } from 'framer-motion'

interface MessageSkeletonProps {
  isUser?: boolean
}

const MessageSkeleton = ({ isUser }: MessageSkeletonProps) => (
  <motion.div
    initial={{ opacity: 0 }}
    animate={{ opacity: 1 }}
    exit={{ opacity: 0 }}
    transition={{ duration: 0.2 }}
    className={cn(
      "flex items-start gap-4 w-full",
      isUser ? "justify-end" : "justify-start"
    )}
  >
    {!isUser && (
      <Avatar className="h-8 w-8 flex-shrink-0">
        <div className="bg-[#7f85c2] text-white flex h-full w-full items-center justify-center rounded-full">
          <Bot className="h-4 w-4" />
        </div>
      </Avatar>
    )}
    <div className={cn(
      "space-y-3 rounded-lg px-4 py-3 max-w-[85%]",
      isUser ? "bg-[#7f85c2] text-white" : "bg-white/5 backdrop-blur"
    )}>
      <motion.div 
        animate={{ 
          opacity: [0.5, 1, 0.5],
          transition: { 
            duration: 1.5,
            repeat: Infinity,
            ease: "linear"
          }
        }}
        className="space-y-2"
      >
        <div className="h-4 w-2/3 bg-white/10 rounded" />
        <div className="h-4 w-1/2 bg-white/10 rounded" />
      </motion.div>
    </div>
    {isUser && (
      <Avatar className="h-8 w-8 flex-shrink-0">
        <div className="bg-white/10 flex h-full w-full items-center justify-center rounded-full">
          <User className="h-4 w-4 text-white" />
        </div>
      </Avatar>
    )}
  </motion.div>
)

interface ProcessedContent {
  books: Book[] | null
  content: string | null
}

interface ChatMessageProps {
  message: Message
  isLoading?: boolean
}

const ChatMessage = memo(({ message, isLoading }: ChatMessageProps) => {
  const [processedContent, setProcessedContent] = useState<ProcessedContent | null>(null)
  const [isProcessing, setIsProcessing] = useState(false)

  useEffect(() => {
    if (!message.content) return

    // Skip processing if the message is a raw book data response
    if (message.content.trim().startsWith('{') && !message.content.includes('</book-data>')) {
      return
    }

    setIsProcessing(true)
    
    try {
      const result = processMessageContent(message.content)
      setProcessedContent(result)
    } catch (error) {
      console.error('Error processing message:', error)
    } finally {
      setIsProcessing(false)
    }
  }, [message.content])

  if (isLoading || isProcessing) {
    return <MessageSkeleton isUser={message.role === 'user'} />
  }

  // Hide raw book data messages
  if (message.role === 'assistant' && message.content.trim().startsWith('{')) {
    return null
  }

  const messageVariants = {
    initial: { 
      opacity: 0,
      y: 20,
      scale: 0.95
    },
    animate: { 
      opacity: 1,
      y: 0,
      scale: 1,
      transition: {
        duration: 0.4,
        ease: [0.4, 0, 0.2, 1]
      }
    },
    exit: { 
      opacity: 0,
      y: -20,
      transition: {
        duration: 0.3
      }
    }
  }

  return (
    <AnimatePresence mode="wait">
      <motion.div
        key={message.id}
        variants={messageVariants}
        initial="initial"
        animate="animate"
        exit="exit"
        className={cn(
          "group relative flex items-start gap-4",
          message.role === "user" ? "justify-end" : "justify-start"
        )}
      >
        {message.role !== "user" && (
          <Avatar className="h-8 w-8 flex-shrink-0">
            <div className="bg-[#7f85c2] text-white flex h-full w-full items-center justify-center rounded-full">
              <Bot className="h-4 w-4" />
            </div>
          </Avatar>
        )}
        
        <div className={cn(
          "flex flex-col gap-4 rounded-lg px-4 py-3 max-w-[85%]",
          message.role === "user" 
            ? "bg-[#7f85c2] text-white" 
            : "bg-white/5 backdrop-blur text-white"
        )}>
          {message.role === "user" ? (
            <motion.div 
              initial={{ opacity: 0 }}
              animate={{ opacity: 1 }}
              transition={{ duration: 0.3 }}
              className="text-sm whitespace-pre-wrap break-words"
            >
              {message.content}
            </motion.div>
          ) : processedContent ? (
            <div className="space-y-6">
              {/* Book Cards Section */}
              <AnimatePresence mode="wait">
                {processedContent.books?.map((book, index) => (
                  <motion.div
                    key={`${book.title}-${book.author}`}
                    initial={{ opacity: 0, y: 20 }}
                    animate={{ opacity: 1, y: 0 }}
                    exit={{ opacity: 0, y: -20 }}
                    transition={{ 
                      duration: 0.5,
                      delay: index * 0.1,
                      ease: [0.4, 0, 0.2, 1]
                    }}
                  >
                    <BookReviewCard {...book} />
                  </motion.div>
                ))}
              </AnimatePresence>
              
              {/* Text Content Section */}
              {processedContent.content && (
                <motion.div 
                  initial={{ opacity: 0, y: 10 }}
                  animate={{ opacity: 1, y: 0 }}
                  transition={{ 
                    duration: 0.4,
                    delay: (processedContent.books?.length || 0) * 0.1 + 0.2
                  }}
                  className="text-sm leading-relaxed text-white/90 space-y-4 prose prose-invert"
                  dangerouslySetInnerHTML={{ 
                    __html: processedContent.content 
                  }}
                />
              )}
            </div>
          ) : null}
        </div>

        {message.role === "user" && (
          <Avatar className="h-8 w-8 flex-shrink-0">
            <div className="bg-white/10 flex h-full w-full items-center justify-center rounded-full">
              <User className="h-4 w-4 text-white" />
            </div>
          </Avatar>
        )}
      </motion.div>
    </AnimatePresence>
  )
})

ChatMessage.displayName = "ChatMessage"

function processMessageContent(content: string): ProcessedContent {
  const bookMatch = content.match(/<book-data>([\s\S]*?)<\/book-data>/g)
  let books = null
  let cleanContent = content

  if (bookMatch) {
    try {
      books = bookMatch.map(match => {
        const bookData = JSON.parse(match.replace(/<\/?book-data>/g, ''))
        return bookData.books?.[0] || bookData
      })
      cleanContent = content.replace(/<book-data>[\s\S]*?<\/book-data>/g, '').trim()
    } catch (error) {
      console.error('Error parsing book data:', error)
    }
  }

  // Process markdown and format text
  cleanContent = cleanContent
    .replace(/\[([^\]]+)\]\((https?:\/\/[^)]+)\)/g, '<a href="$2" target="_blank" rel="noopener noreferrer" class="text-[#7f85c2] hover:underline">$1</a>')
    .replace(/\*\*(.*?)\*\*/g, '<strong class="text-white">$1</strong>')
    .replace(/\_(.*?)\_/g, '<em>$1</em>')
    .replace(/^\s*-\s(.+)$/gm, '<li class="text-white/90">$1</li>')
    .replace(/(<li>.*<\/li>\n?)+/g, '<ul class="list-disc list-inside space-y-1">$&</ul>')
    .replace(/^###\s(.+)$/gm, '<h3 class="text-lg font-semibold text-white mt-4 mb-2">$1</h3>')
    .replace(/^##\s(.+)$/gm, '<h2 class="text-xl font-semibold text-white mt-6 mb-3">$1</h2>')
    .replace(/^#\s(.+)$/gm, '<h1 class="text-2xl font-semibold text-white mt-8 mb-4">$1</h1>')
    .replace(/^>\s*\*\*([^*]+)\*\*/gm, '<blockquote class="border-l-2 border-[#7f85c2] pl-4 py-2 my-4"><strong class="text-white">$1</strong>')
    .replace(/^>\s*(.*?)$/gm, '<blockquote class="border-l-2 border-[#7f85c2] pl-4 py-2 my-4 text-white/90">$1</blockquote>')
    .split('\n\n')
    .map(p => p.trim())
    .filter(p => p)
    .map(p => {
      if (p.startsWith('<')) return p
      return `<p class="text-white/90">${p}</p>`
    })
    .join('\n')

  return {
    books,
    content: cleanContent
  }
}

export default ChatMessage

================
File: components/ui/avatar.tsx
================
"use client"

import * as React from "react"
import * as AvatarPrimitive from "@radix-ui/react-avatar"

import { cn } from "@/lib/utils"

const Avatar = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Root
    ref={ref}
    className={cn(
      "relative flex h-10 w-10 shrink-0 overflow-hidden rounded-full",
      className
    )}
    {...props}
  />
))
Avatar.displayName = AvatarPrimitive.Root.displayName

const AvatarImage = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Image>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Image>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Image
    ref={ref}
    className={cn("aspect-square h-full w-full", className)}
    {...props}
  />
))
AvatarImage.displayName = AvatarPrimitive.Image.displayName

const AvatarFallback = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Fallback>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Fallback>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Fallback
    ref={ref}
    className={cn(
      "flex h-full w-full items-center justify-center rounded-full bg-muted",
      className
    )}
    {...props}
  />
))
AvatarFallback.displayName = AvatarPrimitive.Fallback.displayName

export { Avatar, AvatarImage, AvatarFallback }

================
File: components/ui/badge.tsx
================
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const badgeVariants = cva(
  "inline-flex items-center rounded-md border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground shadow hover:bg-primary/80",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive:
          "border-transparent bg-destructive text-destructive-foreground shadow hover:bg-destructive/80",
        outline: "text-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, ...props }: BadgeProps) {
  return (
    <div className={cn(badgeVariants({ variant }), className)} {...props} />
  )
}

export { Badge, badgeVariants }

================
File: components/ui/button.tsx
================
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground shadow-sm hover:bg-destructive/90",
        outline:
          "border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground shadow-sm hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2",
        sm: "h-8 rounded-md px-3 text-xs",
        lg: "h-10 rounded-md px-8",
        icon: "h-9 w-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button"
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    )
  }
)
Button.displayName = "Button"

export { Button, buttonVariants }

================
File: components/ui/card.tsx
================
import * as React from "react"

import { cn } from "@/lib/utils"

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-xl border bg-card text-card-foreground shadow",
      className
    )}
    {...props}
  />
))
Card.displayName = "Card"

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
))
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("font-semibold leading-none tracking-tight", className)}
    {...props}
  />
))
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
))
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
))
CardFooter.displayName = "CardFooter"

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }

================
File: components/ui/input.tsx
================
import * as React from "react"

import { cn } from "@/lib/utils"

const Input = React.forwardRef<HTMLInputElement, React.ComponentProps<"input">>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-9 w-full rounded-md border border-input bg-transparent px-3 py-1 text-base shadow-sm transition-colors file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Input.displayName = "Input"

export { Input }

================
File: components/ui/scroll-area.tsx
================
"use client"

import * as React from "react"
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area"

import { cn } from "@/lib/utils"

const ScrollArea = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <ScrollAreaPrimitive.Root
    ref={ref}
    className={cn("relative overflow-hidden", className)}
    {...props}
  >
    <ScrollAreaPrimitive.Viewport className="h-full w-full rounded-[inherit]">
      {children}
    </ScrollAreaPrimitive.Viewport>
    <ScrollBar />
    <ScrollAreaPrimitive.Corner />
  </ScrollAreaPrimitive.Root>
))
ScrollArea.displayName = ScrollAreaPrimitive.Root.displayName

const ScrollBar = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>
>(({ className, orientation = "vertical", ...props }, ref) => (
  <ScrollAreaPrimitive.ScrollAreaScrollbar
    ref={ref}
    orientation={orientation}
    className={cn(
      "flex touch-none select-none transition-colors",
      orientation === "vertical" &&
        "h-full w-2.5 border-l border-l-transparent p-[1px]",
      orientation === "horizontal" &&
        "h-2.5 flex-col border-t border-t-transparent p-[1px]",
      className
    )}
    {...props}
  >
    <ScrollAreaPrimitive.ScrollAreaThumb className="relative flex-1 rounded-full bg-border" />
  </ScrollAreaPrimitive.ScrollAreaScrollbar>
))
ScrollBar.displayName = ScrollAreaPrimitive.ScrollAreaScrollbar.displayName

export { ScrollArea, ScrollBar }

================
File: components/ui/textarea.tsx
================
import * as React from "react"

import { cn } from "@/lib/utils"

const Textarea = React.forwardRef<
  HTMLTextAreaElement,
  React.ComponentProps<"textarea">
>(({ className, ...props }, ref) => {
  return (
    <textarea
      className={cn(
        "flex min-h-[60px] w-full rounded-md border border-input bg-transparent px-3 py-2 text-base shadow-sm placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        className
      )}
      ref={ref}
      {...props}
    />
  )
})
Textarea.displayName = "Textarea"

export { Textarea }

================
File: lib/services/chat.ts
================
import { ChatOpenAI } from '@langchain/openai';
import { StringOutputParser } from '@langchain/core/output_parsers';
import { ChatPromptTemplate } from '@langchain/core/prompts';
import { RunnableSequence } from '@langchain/core/runnables';
import { Message } from 'ai';
import { pineconeService } from './pinecone';

const SYSTEM_TEMPLATE = `You are Minerva, an AI assistant for All About Romance (AAR). Your purpose is to help users discover and discuss romance books based on AAR's reviews.

The following metadata is available for relevant books: {metadata}

When discussing specific books, use this exact format for EACH book you mention:

<book-data>
{{{{
  "books": [
    {{{{
      "title": "(use bookTitle from metadata)",
      "author": "(use authorName from metadata)",
      "grade": "(use grade from metadata)",
      "sensuality": "(use sensuality from metadata)",
      "bookTypes": "(use bookTypes array from metadata)",
      "asin": "(use asin from metadata)",
      "reviewUrl": "(use url from metadata)",
      "postId": "(use postId from metadata)",
      "featuredImage": "(use featuredImage from metadata)"
    }}}}
  ]
}}}}
</book-data>

Then structure your response based on the query type:

FOR BOOK REVIEWS:
Start with "Here's what All About Romance thought about [Book Title] by [Author]..."
Then provide:
1. Overview of the book's premise (2-3 sentences)
2. The review grade and reasoning (1-2 sentences)
3. Key points from the review (use bullet points)
4. Reader Reception (if commentCount > 0, include 2-3 notable comments)

FOR RECOMMENDATIONS:
- List 3-4 recommended books
- For each book include the book-data block
- Explain why each book is recommended
- Include grades and key themes

FOR COMPARISONS:
- Use book-data blocks for all books being compared
- Highlight key similarities and differences
- Compare grades, themes, and reader reception
- Provide a balanced analysis

Use only information from the provided context:
{context}

Current conversation:
{chat_history}

Question: {question}

Remember:
1. Include ALL available metadata fields in the book-data block
2. Format book titles and author names exactly as they appear in reviews
3. When there are reader comments, include 2-3 most relevant ones
4. Keep paragraphs concise and well-formatted
5. Use markdown for formatting key points and quotes`;

export class ChatService {
  private llm: ChatOpenAI;
  
  constructor() {
    this.llm = new ChatOpenAI({
      modelName: "gpt-4o-mini",
      temperature: 0.7,
      streaming: true
    });
  }

  private formatChatHistory(messages: Message[]): string {
    return messages
      .slice(0, -1)
      .map(m => `${m.role}: ${m.content}`)
      .join('\n');
  }

  private formatContext(context: string): string {
    return context.trim();
  }

  private extractBookMetadata(docs: any[]): Record<string, any> {
    return docs.reduce((acc: Record<string, any>, doc) => {
      const metadata = doc.metadata;
      if (metadata?.bookTitle && metadata?.authorName) {
        // Create a unique key for each book
        const key = `${metadata.bookTitle}-${metadata.authorName}`;
        
        // Format metadata for the book
        acc[key] = {
          bookTitle: metadata.bookTitle,
          authorName: metadata.authorName,
          grade: metadata.grade,
          sensuality: metadata.sensuality,
          bookTypes: metadata.bookTypes || [],
          asin: metadata.asin,
          url: metadata.url,
          postId: metadata.postId,
          featuredImage: metadata.featuredImage,
          amazonUrl: metadata.amazonUrl,
          reviewerName: metadata.reviewerName,
          publishDate: metadata.publishDate,
          commentCount: metadata.commentCount || 0,
          commentAuthors: metadata.commentAuthors || [],
          commentContents: metadata.commentContents || [],
          reviewTags: metadata.reviewTags || []
        };
      }
      return acc;
    }, {});
  }

  async processMessage(messages: Message[]) {
    const latestMessage = messages[messages.length - 1];
    
    // Get relevant reviews from Pinecone
    const relevantDocs = await pineconeService.getRelevantReviews(
      latestMessage.content
    );
    
    // Extract and format metadata
    const bookMetadata = this.extractBookMetadata(relevantDocs);
    
    // Format context from documents
    const context = relevantDocs
      .map(doc => doc.pageContent)
      .join('\n\n');

    // Create prompt template
    const prompt = ChatPromptTemplate.fromTemplate(SYSTEM_TEMPLATE);

    // Create chain with formatted metadata
    const chain = RunnableSequence.from([
      {
        question: (input: string) => input,
        context: () => this.formatContext(context),
        chat_history: () => this.formatChatHistory(messages),
        metadata: () => JSON.stringify(bookMetadata, null, 2)
      },
      prompt,
      this.llm,
      new StringOutputParser()
    ]);

    return chain.stream(latestMessage.content);
  }
}

export const chatService = new ChatService();

================
File: lib/services/pinecone.ts
================
import { Pinecone } from '@pinecone-database/pinecone';
import { OpenAIEmbeddings } from '@langchain/openai';
import { PineconeStore } from '@langchain/pinecone';
import { Document } from '@langchain/core/documents';
import { ReviewMetadata, formatReviewMetadata } from '../validators/book-data';

export class PineconeService {
  private pinecone: Pinecone;
  private embeddings: OpenAIEmbeddings;
  private indexName: string;

  constructor() {
    this.pinecone = new Pinecone();
    this.embeddings = new OpenAIEmbeddings({
      modelName: "text-embedding-3-small"
    });
    this.indexName = process.env.PINECONE_INDEX_NAME!;
  }

  async getVectorStore() {
    const pineconeIndex = this.pinecone.Index(this.indexName);
    return await PineconeStore.fromExistingIndex(this.embeddings, {
      pineconeIndex
    });
  }

  async getRelevantReviews(query: string, k: number = 4): Promise<Document[]> {
    const vectorStore = await this.getVectorStore();
    const retriever = vectorStore.asRetriever(k);
    
    try {
      return await retriever.getRelevantDocuments(query);
    } catch (error) {
      console.error('Error retrieving documents:', error);
      return [];
    }
  }

  async addReview(review: ReviewMetadata) {
    const vectorStore = await this.getVectorStore();
    const metadata = formatReviewMetadata(review);
    
    // Create document with review content and metadata
    // Format the review content in a structured way
    const pageContent = `
Book Review: ${review.title} by ${review.authorName}
${review.grade ? `Grade: ${review.grade}` : ''}
${review.sensuality ? `Sensuality Rating: ${review.sensuality}` : ''}
${review.bookTypes?.length ? `Categories: ${review.bookTypes.join(', ')}` : ''}
${review.reviewAuthor ? `Reviewed by: ${review.reviewAuthor}` : ''}

Review:
${review.content}

${review.comments?.length ? `Reader Comments:\n${review.comments.map(c => 
  `${c.author} says: ${c.content}`
).join('\n')}` : ''}`.trim();

    const doc = new Document({
      pageContent,
      metadata
    });

    try {
      await vectorStore.addDocuments([doc]);
      return true;
    } catch (error) {
      console.error('Error adding document:', error);
      return false;
    }
  }

  async deleteReview(postId: string) {
    const pineconeIndex = this.pinecone.Index(this.indexName);
    try {
      await pineconeIndex.deleteOne(postId);
      return true;
    } catch (error) {
      console.error('Error deleting document:', error);
      return false;
    }
  }
}

export const pineconeService = new PineconeService();

================
File: lib/validators/book-data.ts
================
import { z } from 'zod';

// Review metadata for Pinecone
export const ReviewMetadataSchema = z.object({
  postId: z.string().optional(),
  title: z.string(),
  authorName: z.string(),
  permalink: z.string().url().optional(),
  featuredImage: z.string().url().optional(),
  excerpt: z.string().optional(),
  content: z.string(),
  grade: z.string().optional(),
  sensuality: z.string().optional(),
  bookTypes: z.array(z.string()).optional(),
  reviewTags: z.array(z.string()).optional(),
  amazonLinks: z.array(z.string().url()).optional(),
  asin: z.string().optional(),
  publishDate: z.string().optional(),
  reviewAuthor: z.string().optional(),
  comments: z.array(z.object({
    author: z.string(),
    content: z.string(),
    date: z.string()
  })).optional()
});

// Book schema for chat responses
export const BookSchema = z.object({
  title: z.string(),
  author: z.string(),
  grade: z.string().optional(),
  sensuality: z.string().optional(),
  bookTypes: z.array(z.string()).optional(),
  asin: z.string().optional(),
  reviewUrl: z.string().url().optional(),
  postId: z.string().optional(),
  featuredImage: z.string().url().optional(),
  excerpt: z.string().optional(),
  reviewAuthor: z.string().optional(),
  publishDate: z.string().optional()
});

// Validation schema for chat responses
export const BookDataSchema = z.object({
  books: z.array(BookSchema)
});

// Export types
export type ReviewMetadata = z.infer<typeof ReviewMetadataSchema>;
export type Book = z.infer<typeof BookSchema>;
export type BookData = z.infer<typeof BookDataSchema>;

// Helper to validate and extract book data from chat responses
export function extractBookData(content: string): BookData | null {
  const bookDataMatch = content.match(/<book-data>(.*?)<\/book-data>/s);
  if (!bookDataMatch) return null;
  
  try {
    const bookData = JSON.parse(bookDataMatch[1]);
    return BookDataSchema.parse(bookData);
  } catch (error) {
    console.error('Error parsing book data:', error);
    return null;
  }
}

// Helper to format review metadata for vector storage
export function formatReviewMetadata(review: ReviewMetadata): Record<string, any> {
  return {
    postId: review.postId,
    title: review.title,
    authorName: review.authorName,
    permalink: review.permalink,
    featuredImage: review.featuredImage,
    excerpt: review.excerpt,
    content: review.content,
    grade: review.grade,
    sensuality: review.sensuality,
    bookTypes: review.bookTypes?.join(', '),
    reviewTags: review.reviewTags?.join(', '),
    amazonLinks: review.amazonLinks?.join(', '),
    asin: review.asin,
    publishDate: review.publishDate,
    reviewAuthor: review.reviewAuthor
  };
}

// Helper to check if string is book data
export function isBookData(content: string): boolean {
  return content.includes('<book-data>') && content.includes('</book-data>');
}

================
File: lib/utils.ts
================
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"
 
export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

================
File: public/file.svg
================
<svg fill="none" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M14.5 13.5V5.41a1 1 0 0 0-.3-.7L9.8.29A1 1 0 0 0 9.08 0H1.5v13.5A2.5 2.5 0 0 0 4 16h8a2.5 2.5 0 0 0 2.5-2.5m-1.5 0v-7H8v-5H3v12a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1M9.5 5V2.12L12.38 5zM5.13 5h-.62v1.25h2.12V5zm-.62 3h7.12v1.25H4.5zm.62 3h-.62v1.25h7.12V11z" clip-rule="evenodd" fill="#666" fill-rule="evenodd"/></svg>

================
File: public/globe.svg
================
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><g clip-path="url(#a)"><path fill-rule="evenodd" clip-rule="evenodd" d="M10.27 14.1a6.5 6.5 0 0 0 3.67-3.45q-1.24.21-2.7.34-.31 1.83-.97 3.1M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16m.48-1.52a7 7 0 0 1-.96 0H7.5a4 4 0 0 1-.84-1.32q-.38-.89-.63-2.08a40 40 0 0 0 3.92 0q-.25 1.2-.63 2.08a4 4 0 0 1-.84 1.31zm2.94-4.76q1.66-.15 2.95-.43a7 7 0 0 0 0-2.58q-1.3-.27-2.95-.43a18 18 0 0 1 0 3.44m-1.27-3.54a17 17 0 0 1 0 3.64 39 39 0 0 1-4.3 0 17 17 0 0 1 0-3.64 39 39 0 0 1 4.3 0m1.1-1.17q1.45.13 2.69.34a6.5 6.5 0 0 0-3.67-3.44q.65 1.26.98 3.1M8.48 1.5l.01.02q.41.37.84 1.31.38.89.63 2.08a40 40 0 0 0-3.92 0q.25-1.2.63-2.08a4 4 0 0 1 .85-1.32 7 7 0 0 1 .96 0m-2.75.4a6.5 6.5 0 0 0-3.67 3.44 29 29 0 0 1 2.7-.34q.31-1.83.97-3.1M4.58 6.28q-1.66.16-2.95.43a7 7 0 0 0 0 2.58q1.3.27 2.95.43a18 18 0 0 1 0-3.44m.17 4.71q-1.45-.12-2.69-.34a6.5 6.5 0 0 0 3.67 3.44q-.65-1.27-.98-3.1" fill="#666"/></g><defs><clipPath id="a"><path fill="#fff" d="M0 0h16v16H0z"/></clipPath></defs></svg>

================
File: public/next.svg
================
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 394 80"><path fill="#000" d="M262 0h68.5v12.7h-27.2v66.6h-13.6V12.7H262V0ZM149 0v12.7H94v20.4h44.3v12.6H94v21h55v12.6H80.5V0h68.7zm34.3 0h-17.8l63.8 79.4h17.9l-32-39.7 32-39.6h-17.9l-23 28.6-23-28.6zm18.3 56.7-9-11-27.1 33.7h17.8l18.3-22.7z"/><path fill="#000" d="M81 79.3 17 0H0v79.3h13.6V17l50.2 62.3H81Zm252.6-.4c-1 0-1.8-.4-2.5-1s-1.1-1.6-1.1-2.6.3-1.8 1-2.5 1.6-1 2.6-1 1.8.3 2.5 1a3.4 3.4 0 0 1 .6 4.3 3.7 3.7 0 0 1-3 1.8zm23.2-33.5h6v23.3c0 2.1-.4 4-1.3 5.5a9.1 9.1 0 0 1-3.8 3.5c-1.6.8-3.5 1.3-5.7 1.3-2 0-3.7-.4-5.3-1s-2.8-1.8-3.7-3.2c-.9-1.3-1.4-3-1.4-5h6c.1.8.3 1.6.7 2.2s1 1.2 1.6 1.5c.7.4 1.5.5 2.4.5 1 0 1.8-.2 2.4-.6a4 4 0 0 0 1.6-1.8c.3-.8.5-1.8.5-3V45.5zm30.9 9.1a4.4 4.4 0 0 0-2-3.3 7.5 7.5 0 0 0-4.3-1.1c-1.3 0-2.4.2-3.3.5-.9.4-1.6 1-2 1.6a3.5 3.5 0 0 0-.3 4c.3.5.7.9 1.3 1.2l1.8 1 2 .5 3.2.8c1.3.3 2.5.7 3.7 1.2a13 13 0 0 1 3.2 1.8 8.1 8.1 0 0 1 3 6.5c0 2-.5 3.7-1.5 5.1a10 10 0 0 1-4.4 3.5c-1.8.8-4.1 1.2-6.8 1.2-2.6 0-4.9-.4-6.8-1.2-2-.8-3.4-2-4.5-3.5a10 10 0 0 1-1.7-5.6h6a5 5 0 0 0 3.5 4.6c1 .4 2.2.6 3.4.6 1.3 0 2.5-.2 3.5-.6 1-.4 1.8-1 2.4-1.7a4 4 0 0 0 .8-2.4c0-.9-.2-1.6-.7-2.2a11 11 0 0 0-2.1-1.4l-3.2-1-3.8-1c-2.8-.7-5-1.7-6.6-3.2a7.2 7.2 0 0 1-2.4-5.7 8 8 0 0 1 1.7-5 10 10 0 0 1 4.3-3.5c2-.8 4-1.2 6.4-1.2 2.3 0 4.4.4 6.2 1.2 1.8.8 3.2 2 4.3 3.4 1 1.4 1.5 3 1.5 5h-5.8z"/></svg>

================
File: public/vercel.svg
================
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1155 1000"><path d="m577.3 0 577.4 1000H0z" fill="#fff"/></svg>

================
File: public/window.svg
================
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 2.5h13v10a1 1 0 0 1-1 1h-11a1 1 0 0 1-1-1zM0 1h16v11.5a2.5 2.5 0 0 1-2.5 2.5h-11A2.5 2.5 0 0 1 0 12.5zm3.75 4.5a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5M7 4.75a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0m1.75.75a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5" fill="#666"/></svg>

================
File: scripts/inspect-db.ts
================
import { Pinecone } from '@pinecone-database/pinecone';
import dotenv from 'dotenv';

dotenv.config({ path: '.env.local' });

async function inspectPineconeDB() {
  try {
    // Initialize Pinecone
    const pinecone = new Pinecone();
    const indexName = process.env.PINECONE_INDEX_NAME!;
    
    if (!indexName) {
      throw new Error('PINECONE_INDEX_NAME not found in environment variables');
    }

    console.log('\n Connecting to Pinecone index:', indexName);
    const index = pinecone.Index(indexName);

    // Get index statistics
    console.log('\n Fetching index statistics...');
    const stats = await index.describeIndexStats();
    
    console.log('\nIndex Statistics:');
    console.log('-----------------');
    console.log(`Total Record Count: ${stats.totalRecordCount}`);
    console.log(`Dimension: ${stats.dimension}`);
    console.log('\nNamespace Distribution:');
    if (stats.namespaces) {
      for (const [namespace, stat] of Object.entries(stats.namespaces)) {
        console.log(`- ${namespace || 'default'}: ${stat.recordCount} records`);
      }
    }

    // Create a zero vector for querying (using the index dimension)
    const dimension = stats.dimension || 1536; // Use index dimension or default to 1536
    const queryVector = new Array(dimension).fill(0);

    // Query all documents
    console.log('\n Fetching documents...');
    const queryResponse = await index.query({
      vector: queryVector,
      topK: 100,
      includeMetadata: true,
      includeValues: false,
    });

    const matches = queryResponse.matches || [];
    console.log(`\nFound ${matches.length} documents`);

    // Analyze metadata fields
    const metadataFields = new Set<string>();
    matches.forEach(match => {
      if (match.metadata) {
        Object.keys(match.metadata).forEach(key => metadataFields.add(key));
      }
    });

    console.log('\n Available Metadata Fields:');
    console.log('-------------------------');
    console.log(Array.from(metadataFields).sort().join('\n'));

    // Display document details
    console.log('\n Document Details:');
    console.log('----------------');
    
    matches.forEach((match, idx) => {
      console.log(`\nDocument ${idx + 1}:`);
      console.log('-------------');
      console.log('ID:', match.id);
      console.log('Score:', match.score);
      
      if (match.metadata) {
        console.log('\nMetadata:');
        // Format metadata for better readability
        const formattedMetadata: Record<string, unknown> = { ...match.metadata };

        // Truncate long text fields for readability
        ['content', 'excerpt'].forEach(field => {
          if (typeof match.metadata?.[field] === 'string') {
            formattedMetadata[field] = (match.metadata[field] as string).substring(0, 200) + '...';
          }
        });

        console.dir(formattedMetadata, { depth: null, colors: true });
      }
    });

    // Print summary statistics
    console.log('\n Summary:');
    console.log('---------');
    console.log(`Total documents: ${matches.length}`);
    console.log(`Metadata fields: ${metadataFields.size}`);
    
    // Check for potential issues
    const documentsWithoutTitle = matches.filter(m => !m.metadata?.title).length;
    const documentsWithoutContent = matches.filter(m => !m.metadata?.content).length;
    
    if (documentsWithoutTitle > 0 || documentsWithoutContent > 0) {
      console.log('\n  Potential Issues:');
      console.log('------------------');
      if (documentsWithoutTitle > 0) {
        console.log(`- ${documentsWithoutTitle} documents missing title`);
      }
      if (documentsWithoutContent > 0) {
        console.log(`- ${documentsWithoutContent} documents missing content`);
      }
    }

  } catch (error) {
    console.error('\n Error inspecting Pinecone DB:', error);
    throw error;
  }
}

// Run the inspection
console.log(' Starting Pinecone DB inspection...');

inspectPineconeDB()
  .then(() => {
    console.log('\n Inspection complete!');
    process.exit(0);
  })
  .catch((error) => {
    console.error('\n Fatal error:', error);
    process.exit(1);
  });

================
File: types/chat.ts
================
import { Message } from 'ai'

export interface ReviewMetadata {
  bookTitle: string;
  authorName: string;
  grade: string;
  sensuality: string;
  bookTypes?: string[];
  reviewTags?: string[];
  text: string;
}

export interface PineconeMatch {
  id: string;
  score: number;
  metadata?: ReviewMetadata;
}

export type ChatMessage = Message;

export interface ChatProps {
  initialMessages?: Message[];
  id?: string;
}

export interface BookData {
  title: string;
  author: string;
  grade?: string;
  sensuality?: string;
  bookTypes?: string[];
  asin?: string;
  reviewUrl?: string;
  postId?: string;
  featuredImage?: string;
}

================
File: .eslintrc.json
================
{
  "extends": ["next/core-web-vitals"],
  "parserOptions": {
    "project": "./tsconfig.json"
  }
}

================
File: .gitignore
================
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# env files (can opt-in for committing if needed)
.env*

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts

================
File: components.json
================
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "tailwind.config.ts",
    "css": "app/globals.css",
    "baseColor": "neutral",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "iconLibrary": "lucide"
}

================
File: next.config.js
================
/** @type {import('next').NextConfig} */
const nextConfig = {
  /* config options here */
}

module.exports = nextConfig

================
File: package.json
================
{
  "name": "minerva",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "see-db": "tsx scripts/inspect-db.ts"
  },
  "dependencies": {
    "@ai-sdk/openai": "^1.0.5",
    "@langchain/community": "^0.3.16",
    "@langchain/openai": "^0.3.14",
    "@langchain/pinecone": "^0.1.3",
    "@pinecone-database/pinecone": "^4.0.0",
    "@radix-ui/react-avatar": "^1.1.1",
    "@radix-ui/react-scroll-area": "^1.2.1",
    "@radix-ui/react-slot": "^1.0.2",
    "ai": "^4.0.7",
    "class-variance-authority": "^0.7.0",
    "clsx": "^2.1.1",
    "framer-motion": "^11.12.0",
    "langchain": "^0.3.6",
    "lucide-react": "^0.309.0",
    "minimatch": "^3.1.2",
    "next": "14.1.0",
    "openai": "^4.73.1",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-intersection-observer": "^9.13.1",
    "repomix": "^0.2.5",
    "sonner": "^1.7.0",
    "tailwind-merge": "^2.5.5",
    "zod": "^3.23.8"
  },
  "devDependencies": {
    "@tailwindcss/typography": "^0.5.15",
    "@types/node": "^20",
    "@types/react": "^18",
    "@types/react-dom": "^18",
    "autoprefixer": "^10.4.20",
    "eslint": "^8",
    "eslint-config-next": "14.1.0",
    "postcss": "^8.4.49",
    "tailwindcss": "^3.4.15",
    "tailwindcss-animate": "^1.0.7",
    "typescript": "^5"
  }
}

================
File: postcss.config.js
================
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}

================
File: postcss.config.mjs
================
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}

================
File: README.md
================
# Project Minerva: AI-Powered Romance Book Review Chatbot

## Project Overview
Project Minerva is an intelligent chatbot system designed specifically for All About Romance, a WordPress-based romance book review platform. The chatbot aims to enhance user engagement by providing natural, context-aware conversations about romance books, reviews, and recommendations.

## Core Objectives
1. Create an intuitive, conversational interface for exploring romance book reviews
2. Integrate seamlessly with existing WordPress infrastructure
3. Provide accurate, context-aware responses to user queries
4. Scale efficiently to handle growing user interactions
5. Maintain conversation history and context for meaningful interactions

## Key Features

### 1. Natural Language Understanding
- Process and understand user queries about books, authors, and reviews
- Handle complex questions about plot elements, character dynamics, and themes
- Support follow-up questions and maintain conversation context
- Example queries:
  - "What are the best enemies-to-lovers romances from 2024?"
  - "Find me books similar to 'The Love Hypothesis'"
  - "What did reviewers say about the character development in this book?"

### 2. Review Integration
- Access and analyze existing book reviews from the WordPress database
- Incorporate user comments and ratings into responses
- Provide balanced perspectives from multiple reviews
- Generate comprehensive summaries of review content

### 3. Recommendation Engine
- Suggest similar books based on user preferences
- Filter recommendations by subgenre, tropes, heat level, etc.
- Consider review ratings and user feedback in suggestions
- Provide personalized reading lists

### 4. WordPress Integration
- Seamless embedding in WordPress pages and posts
- Real-time access to review database
- Consistent styling with website theme
- Mobile-responsive design

## Technical Architecture

### Frontend Stack
1. **Next.js 14**
   - App Router for routing
   - Server Components for optimal performance
   - API Routes for backend functionality
   - Tailwind CSS for styling
   - TypeScript for type safety

2. **UI Components**
   - Shadcn/ui for core components
   - Custom chat interface
   - Loading states and animations
   - Error handling and feedback

### Backend Services

1. **LangChain Framework**
   - RAG (Retrieval-Augmented Generation) implementation
   - Conversation chain management
   - Context window optimization
   - Memory management for chat history

2. **Vector Database (Pinecone)**
   - Store and retrieve review embeddings
   - Semantic search capabilities
   - Real-time updates for new content
   - Efficient similarity search

3. **WordPress Integration**
   - WPGraphQL plugin for data access
   - Custom post type for reviews
   - Real-time content synchronization
   - User authentication integration

### Data Flow
1. Content Processing
   ```
   WordPress Reviews  Vector Embeddings  Pinecone DB
   ```

2. Query Processing
   ```
   User Query  LangChain  Vector Search  LLM  Response
   ```

3. Context Management
   ```
   Chat History  Memory System  Context Window  Response Generation
   ```

## Development Phases

### Phase 1: Foundation
- Set up Next.js project structure
- Implement basic chat interface
- Configure WordPress GraphQL integration
- Set up development and staging environments

### Phase 2: Core Features
- Implement RAG system with LangChain
- Set up vector database and embeddings
- Create basic conversation flows
- Develop review parsing system

### Phase 3: Enhancement
- Add advanced query handling
- Implement recommendation system
- Optimize response generation
- Add error handling and fallbacks

### Phase 4: WordPress Plugin
- Develop WordPress plugin
- Create admin interface
- Implement configuration options
- Add analytics and monitoring

## Deployment Strategy
1. **Frontend**
   - Vercel for Next.js application
   - Automated deployments from GitHub
   - Environment variable management
   - Performance monitoring

2. **Backend Services**
   - Serverless functions for API endpoints
   - Vector database hosting
   - WordPress plugin distribution
   - Backup and recovery systems

## Monitoring and Maintenance
- Track user interactions and feedback
- Monitor system performance
- Regular updates to vector database
- Continuous improvement of responses

## Security Considerations
- User data protection
- API key management
- Rate limiting
- Error logging and monitoring
- GDPR compliance

## Future Enhancements
1. User preference learning
2. Multi-language support
3. Voice interface
4. Advanced analytics dashboard
5. Integration with e-commerce systems

## Project Constraints
- API rate limits
- Content freshness
- Response time requirements
- Resource optimization
- Cost management

## Success Metrics
1. User engagement rates
2. Response accuracy
3. Query resolution time
4. User satisfaction scores
5. System uptime and reliability

This document serves as a living reference for Project Minerva's development and can be updated as the project evolves.

================
File: tailwind.config.ts
================
import type { Config } from "tailwindcss"

const config = {
  content: [
    "./app/**/*.{js,ts,jsx,tsx,mdx}",
    "./pages/**/*.{js,ts,jsx,tsx,mdx}",
    "./components/**/*.{js,ts,jsx,tsx,mdx}",
  ],
  theme: {
    extend: {
      fontFamily: {
        sans: ['var(--font-inter)', 'system-ui', 'sans-serif'],
        serif: ['var(--font-dm-serif)', 'serif'],
      },
      colors: {
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))",
        },
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))",
        },
      },
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
      },
    },
  },
  plugins: [
    require("tailwindcss-animate"),
    require("@tailwindcss/typography")
  ],
} satisfies Config

export default config

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "target": "es2018",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
